'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-go/docs/basic/grammar/keyword/','title':"1.1 关键字",'content':"Go 语言关键字 for 与 range select defer panic 与 recover make 与 new "});index.add({'id':1,'href':'/study-go/docs/basic/practice/spec/baidu/','title':"百度",'content':"百度 Golang 编码规范 V1.2 1. 前言 1.1. 一般信息【重要必读】   此编码风格指南主要基于 BFE 组 Golang 编程规范和 CodeReviewComments 制定。\n  这份文档存在的意义是让大家写出统一风格的代码，让百度的模块可维护性和可读性更好；\n  文档内容可能会与您的喜好冲突， 请尽量用包容的心态来接受；不合理之处， 请反馈给 go-styleguide@baidu.com\n  1.2. 如何使用本编程规范 本规范的层次结构   本规范可分为三大部分，分别对 Go 语法、风格、编程实践作出规定与建议。\n  每一部分有若干专题，每一专题下有若干条目。\n  条目是规范的基本组成部分，每一条目由规定、定义、解释、示例、参考等项组成。\n  条目的级别和编号   本规范的条目分两个级别\n  RULE：要求所有程序必须遵守，不得违反\n  ADVICE：建议遵守，除非确有特殊情况\n  本规范所有条目都有编号，用来标识单条规范并用于自动化检查工具错误提示。\n  标号由 \u0026ldquo;RULE\u0026rdquo; 或 \u0026ldquo;ADVICE\u0026rdquo; 和三位数字标识，例如 RULE001, ADVICE001\n  1.3. 说明   本规范由 “百度 Golang 编程规范小组制定”，小组成员请参考 golang 编程规范工作组\n  特别感谢参与规范修订的以下同学：陶春华 (taochunhua)、简恒懿 (jianhengyi)、黄添来 (huangtianlai01)、李景晨（lijingchen）、王炜煜（wangweiyu02)、李晓萌 (lixiaomeng01)、赵新 (zhaoxin08)。\n  2. 语言规范 2.1 true/false 求值    {RULE001} 当明确 expr 为 bool 类型时，禁止使用 == 或！= 与 true/false 比较，应该使用 expr 或！expr\n  {RULE002} 判断某个整数表达式 expr 是否为零时，禁止使用！expr，应该使用 expr == 0\n  示例\nGOOD: var isWhiteCat bool var num int if isWhiteCat { // ... } if num == 0 { // ... } BAD: var isWhiteCat bool var num int if isWhite == true { // ... } if !num { // ... } 2.2 Receiver 2.2.1 Receiver Type    {RULE003} 如果 receiver 是 map、函数或者 chan 类型，类型不可以是指针\n  {RULE004} 如果 receiver 是 slice，并且方法不会进行 reslice 或者重新分配 slice，类型不可以是指针\n  {RULE005} 如果 receiver 是 struct，且包含 sync.Mutex 类型字段，则必须使用指针避免拷贝。\n  {ADVICE001} 如果 receiver 是比较大的 struct/array，建议使用指针，这样会更有效率\n  {ADVICE002} 如果 receiver 是 struct、array 或 slice，其中指针元素所指的内容可能在方法内被修改，建议使用指针类型\n  {ADVICE003} 如果 receiver 是比较小的 struct/array，建议使用 value 类型\n  解释\n  关于 receiver 的定义详见 Receiver 定义：The receiver is specified via an extra parameter section preceeding the method name. That parameter section must declare a single parameter, the receiver. Its type must be of the form T or *T (possibly using parentheses) where T is a type name. The type denoted by T is called the receiver base type; it must not be a pointer or interface type and it must be declared in the same package as the method. The method is said to be bound to the base type and the method name is visible only within selectors for that type.\n  struct 或者 array 中的元素个数超过 3 个，则认为比较大，反之，则认为比较小\n  2.2.2 receiver 命名    {ADVICE004} 尽量简短并有意义。\n  {RULE006} 禁止使用 “this\u0026rdquo;、”self“等面向对象语言中特定的叫法。\n  {ADVICE005} receiver 的命名要保持一致性\n  示例\nGOOD： // call()和done()都使用了在上下文中有意义的\u0026quot;c\u0026quot;进行receiver命名 func (c Client) call() error { // \u0026hellip; }\nfunc (c Client) done() error { // \u0026hellip; }\n BAD：\n// 1. \u0026quot;c\u0026quot;和\u0026quot;client\u0026quot;命名不一致：done()用了c，call()用了client // 2. client命名过于冗余\nfunc (c Client) done() error { // ... } func (client Client) call() error { // ... } // 不允许使用self func (self Server) rcv() error { // ... } // 不允许使用this func (this Server) call() error { // ... } ``` ### 2.3 申明空 Slices * {**ADVICE006**} 申明 slice 时，建议使用 var 方式申明，不建议使用大括号的方式 解释 * var 方式申明在 slice 不被 append 的情况下避免了内存分配 示例 ``` GOOD: var t \\[\\]string ``` ``` BAD: t := \\[\\]string{} ``` ### 2.4 Error Handler * {**RULE007**} 对于返回值中的 error，一定要进行判断和处理，不可以使用 ”_“ 变量忽略 error ### 2.5 \u0026quot;{\u0026quot; 的使用 * {**RULE008**} struct、函数、条件判断中的 “{”，不可以作为独立的一行 示例 ``` GOOD: if condition { // ... } else { // ... } ``` ``` BAD: // \u0026quot;{\u0026quot;不可以作为独立行 if condition { // ... } else { // ... } ``` ### 2.6 [embedding](http://golang.org/doc/effective_go.html#embedding) 的使用 * {**ADVICE007**} embedding 只用于 \u0026quot;is a\u0026quot; 的语义下，而不用于 \u0026quot;has a\u0026quot; 的语义下 * {**ADVICE008**} 一个定义内，多于一个的 embedding 尽量少用 解释 * 语义上 embedding 是一种 “继承关系 “，而不是” 成员关系 “ * 一个定义内有多个 embedding，则很难判断某个成员变量或函数是从哪里继承得到的 * 一个定义内有多个 embedding，危害和在 python 中使用”from xxx import *\u0026quot; 是类似的 示例 ``` GOOD: type Automobile struct { // ... } type Engine struct { // .... } // 正确的定义 type Car struct { Automobile // Car is a Automobile engine Engine // Car has a Engine } ``` ``` BAD: type Car struct { Automobile // Car is a Automobile Engine // Car has a Engine, but Car is NOT a Engine } ``` 3\\. 风格规范 -------- ### 3.1 Go 文件 Layout * {**ADVICE009**} 建议文件按以下顺序进行布局 * General Documentation： 对整个模块和功能的完整描述注释，写在文件头部。 * package：当前 package 定义 * imports：包含的头文件 * Constants：常量 * Typedefs： 类型定义 * Globals：全局变量定义 * functions：函数实现 示例 ``` GOOD: /* Copyright 2015 Baidu Inc. All Rights Reserved. */ /* bfe_server.go - the main structure of bfe-server */ /* modification history \\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\- 2014/6/5, by Zhang San, create */ /* DESCRIPTION This file contains the most important struct 'BfeServer' of go-bfe and new/init method of the struct. */ package bfe_server // imports import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) import ( \u0026quot;code.google.com/p/log4go\u0026quot;  \u0026ldquo;icode.baidu.com/baidu/searchbox/golib\u0026rdquo; )\nimport ( \u0026ldquo;bfe_config/bfe_conf\u0026rdquo; \u0026ldquo;bfe_module\u0026rdquo; )\nconst ( version = \u0026ldquo;1.0.0.0\u0026rdquo; )\n// typedefs type BfeModule interface { Init(cfg bfe_conf.BfeConfig, cbs *BfeCallbacks) error }\ntype BfeModules struct { modules map[string]BfeModule }\n// vars var errTooLarge = errors.New(\u0026ldquo;http: request too large\u0026rdquo;)\n//functions func foo() { //\u0026hellip; }\n * {**RULE009**} 对于以上的各个部分，采用单个空行分割，同时： * 多个类型定义采用单个空行分割 * 多个函数采用单个空行分割 * {**ADVICE010**} 函数内不同的业务逻辑处理建议采用单个空行分割 * {**ADVICE011**} 常量或者变量如果较多，建议按照业务进行分组，组间用单个空行分割 ### 3.2 General Documentation Layout * {**ADVICE012**} 建议每个文件开头部分包括文件 copyright 说明（copyright） * {**ADVICE013**} 建议每个文件开头部分包括文件标题（Title） * {**ADVICE014**} 建议每个文件开头部分包括修改记录（Modification History） * {**ADVICE015**} 建议每个文件开头部分包括文件描述（Description） 解释 * Title 中包括文件的名称和文件的简单说明 * Title 应该在一行内完成 * Modification History 记录文件的修改过程，并且只记录最主要的修改 * 当书写新的函数模块时，只需要使用形如 \u0026quot;Add func1 ()\u0026quot; 这样的说明 * 如果后面有对函数中的算法进行了修改，需要指出修改的具体位置和修改方法 * Modification History 的具体格式为：\u0026lt;修改时间\u0026gt;, \u0026lt; 修改人 \u0026gt;, \u0026lt; 修改动作 \u0026gt; * Description 详细描述文件的功能和作用 示例 GOOD: /* Copyright 2015 Baidu Inc. All Rights Reserved. */ /* bfe_server.go - the main structure of bfe-server */ /* modification history -------------------- 2014/6/5, by Zhang San, create */ /* DESCRIPTION This file contains the most important struct \u0026lsquo;BfeServer\u0026rsquo; of go-bfe and new/init method of the struct. */\npackage bfe_server\nfunc func1() { // \u0026hellip; }\n BAD: package bfe_server\nfunc func1() { // \u0026hellip; }\n ### 3.3 import 规范 * {**RULE010**} 需要按照如下顺序进行头文件 import，并且每个 import 部分内的 package 需按照字母升序排列 * 系统 package * 第三方的 package * 程序自己的 package * {**RULE011**} 每部分 import 间用单个空行进行分隔 示例： GOOD： import ( \u0026ldquo;fmt\u0026rdquo; \u0026ldquo;time\u0026rdquo; )\nimport ( \u0026ldquo;code.google.com/p/log4go\u0026rdquo;\n \u0026quot;icode.baidu.com/baidu/searchbox/golib\u0026quot; )\nimport ( \u0026ldquo;bfe_config/bfe_conf\u0026rdquo; \u0026ldquo;bfe_module\u0026rdquo; )\n GOOD： import ( \u0026ldquo;fmt\u0026rdquo; \u0026ldquo;time\u0026rdquo;\n \u0026ldquo;code.google.com/p/log4go\u0026rdquo;\n \u0026ldquo;bfe_config/bfe_conf\u0026rdquo; \u0026ldquo;bfe_module\u0026rdquo; )\n BAD： // 同一类package内import顺序需按字母升序排序 import ( “time\u0026rdquo; \u0026ldquo;fmt\u0026rdquo; )\n// 不同类的package import顺序出错（先第三方package，再程序自己的package） import ( \u0026ldquo;bfe_config/bfe_conf\u0026rdquo; \u0026ldquo;bfe_module\u0026rdquo; )\nimport ( \u0026ldquo;code.google.com/p/log4go\u0026rdquo; )\n BAD： import ( // 同一类package内import顺序出错 “time\u0026rdquo; \u0026ldquo;fmt\u0026rdquo;\n // 不同类的package import顺序出错（先第三方package，再程序自己的package） \u0026ldquo;bfe_config/bfe_conf\u0026rdquo; \u0026ldquo;bfe_module\u0026rdquo;\n \u0026ldquo;code.google.com/p/log4go\u0026rdquo; )\n ### 3.4 Go 函数 Layout #### 3.4.1 函数注释 * {**ADVICE016**} 函数的注释，建议包括以下内容 * Description：对函数的完整描述，主要包括函数功能和使用方法 * Params：对参数的说明 * Returns：对返回值的说明 示例 /* * Init - initialize log lib * * PARAMS: * - levelStr: \u0026ldquo;DEBUG\u0026rdquo;, \u0026ldquo;TRACE\u0026rdquo;, \u0026ldquo;INFO\u0026rdquo;, \u0026ldquo;WARNING\u0026rdquo;, \u0026ldquo;ERROR\u0026rdquo;, \u0026ldquo;CRITICAL\u0026rdquo; * - when: * \u0026ldquo;M\u0026rdquo;, minute * \u0026ldquo;H\u0026rdquo;, hour * \u0026ldquo;D\u0026rdquo;, day * \u0026ldquo;MIDNIGHT\u0026rdquo;, roll over at midnight * - backupCount: If backupCount is \u0026gt; 0, when rollover is done, no more than * backupCount files are kept - the oldest ones are deleted. * * RETURNS: * nil, if succeed * error, if fail */ func Init(levelStr string, when string, backupCount int) error { // \u0026hellip; }\n #### 3.4.2 函数参数和返回值 * {**ADVICE017**} 对于 “逻辑判断型” 的函数，返回值的意义代表 “真” 或 “假”，返回值类型定义为 bool * {**ADVICE018**} 对于 “操作型” 的函数，返回值的意义代表 “成功” 或 “失败”，返回值类型定义为 error * 如果成功，则返回 nil * 如果失败，则返回对应的 error 值 * {**ADVICE019**} 对于 “获取数据型” 的函数，返回值的意义代表 “有数据” 或 “无数据 / 获取数据失败”，返回值类型定义为（data, error） * 正常情况下，返回为：（data, nil） * 异常情况下，返回为：（data, error） * {**RULE012**} 函数返回值小于等于 3 个，大于 3 个时必须通过 struct 进行包装 * {**ADVICE020**} 函数参数不建议超过 3 个，大于 3 个时建议通过 struct 进行包装 示例： GOOD： type student struct { name string email string id int class string }\n// bool作为逻辑判断型函数的返回值 func isWhiteCat() bool { // \u0026hellip; }\n// error作为操作型函数的返回值 func deleteData() error { // \u0026hellip; }\n// 利用多返回值的语言特性 func getData() (student, error) { // \u0026hellip; }\n BAD： type student struct { name string email string id int class string }\n// 使用int而非bool作为逻辑判断函数的返回值 func isWhiteCat() int { // \u0026hellip; }\n// 操作型函数没有返回值 func deleteData() { // \u0026hellip; }\n// 没有充分利用go多返回值的特点 func getData() student { // \u0026hellip; }\n// 返回值\u0026gt;3 func getData() (string, string, int, string, error) { // \u0026hellip; }\n ### 3.5 程序规模 * {**RULE013**} 每行代码不超过 100 个字符。 * {**RULE014**} 每行注释不超过 100 个字符。 * {**ADVICE021**} 函数不超过 100 行。 * {**ADVICE022**} 文件不超过 2000 行。 解释 * 现在宽屏比较流行，所以从传统的 80 个字符限制扩展到 100 个字符 * 函数 / 文件太长一般说明函数定义不明确 / 程序结构划分不合理，不利于维护 ### 3.6 命名规范 #### 3.6.1 文件名 * {**RULE015**} 文件名都使用小写字母，如果需要，可以使用下划线分割 * {**RULE016**} 文件名的后缀使用小写字母 示例： GOOD： // 可以使用下划线分割文件名 web_server.go\n// 文件名全部小写 http.go\n BAD： // 文件名不允许出现大写字符 webServer.go\n// 文件名后缀不允许出现大写字符 http.GO\n #### 3.6.2 函数名 / 变量名 * {**RULE017**} 采用驼峰方式命名，禁止使用下划线命名。首字母是否大写，根据是否需要外部访问来决定 示例： GOOD： // 本package可以访问的函数 func innerFunc() bool { // \u0026hellip; }\n// 其余package可以访问的函数 func OuterFunc() error { // \u0026hellip; }\n BAD： // 禁止用下划线分割 func inner_Func() bool { var srv_name string // \u0026hellip; }\n// 禁止用下划线分割 // 其余package可以访问的函数 func Outer_Func() error { // \u0026hellip; }\n #### 3.6.3 常量 * {**ADVICE024**} 尽量不要在程序中直接写数字，特殊字符串，全部用常量替代 #### 3.6.4 缩写词 * {**RULE018**} 缩写词要保持命名的一致性。 * 同一变量字母大小写的一致性 * 不同变量间的一致性 示例： GOOD： var URL string\nvar ID int var appID int\ntype ServeURL struct { // \u0026hellip; }\n BAD： var Url string\n// not consistent var ID int var appid int\ntype ServUrl struct { // \u0026hellip; }\n ### 3.7 缩进 * {**RULE019**} 使用 tab 进行缩进。 * {**RULE020**} 跨行的缩进使用 gofmt 的缩进方式。 * {**RULE021**} 设置 tabstop=4 解释 * 要求设置 tabstop=4 是考虑到不同编辑器跨行字符串对齐显示的一致性，比如下面的例子： 1 2 3 4 5 6 `func main() {` ``rows, err := e.db.Query(`SELECT id, name, state, create_ts, start_ts`` `FROM workflow` `WHERE state=? AND create_ts=?` ``ORDER BY start_ts DESC`)`` `}` 示例： GOOD： func longFunctionName(var_one, var_two, var_three, var_four) { // \u0026hellip; }\n BAD： func longFunctionName(var_one, var_two, var_three, var_four) { // \u0026hellip; }\n * * {**ADVICE025**} 错误处理时缩进错误处理代码，对正常代码保持最少的缩进。 示例 GOOD： if err != nil { // error handling return // or continue, etc. } // normal code\n BAD： if err != nil { // error handling } else { // normal code }\n ### 3.8 空格 * {**RULE022**} 圆括号、方括号、花括号内侧都不加空格 * {**RULE023**} 逗号、冒号（slice 中冒号除外）前不加空格，后边加一个空格 * {**RULE024**} 所有二元运算符前后各加一个空格（作为函数参数时除外） ``` GOOD： var ( s = make(\\[\\]int, 10) ) func foo() { m := map\\[string\\]string{\u0026quot;language\u0026quot;: \u0026quot;golang\u0026quot;} r := 1 + 2 func1(1+2) fmt.Println(m\\[\u0026quot;language\u0026quot;\\]) } ``` ``` BAD： var ( s = make( \\[\\]int , 10 ) ) func foo() { m := map\\[string\\]string{ \u0026quot;language\u0026quot; : \u0026quot;golang\u0026quot; } r := 1+2 func1(1 + 2) fmt.Println(m\\[ \u0026quot;language\u0026quot; \\]) } ``` ### 3.9 括号 * {**ADVICE026**} 除非用于明确算术表达式优先级，否则尽量避免冗余的括号 GOOD： if x { }\nfunc func1() int { var num int return num }\n BAD： if (x) { }\nfunc func1 int { var num int return (num) }\n ### 3.10 注释 * {**ADVICE027**} 单行注释，采取 \u0026quot;//\u0026quot; 或者 \u0026quot;/*...*/\u0026quot; 的注释方式。 * {**ADVICE028**} 多行注释，采取每行开头 “//\u0026quot;或者用\u0026quot;/\\* ... */\u0026quot;包括起来的注释（\u0026quot;/*\u0026quot;和\u0026quot;*/\u0026quot; 作为独立的行） * {**ADVICE029**} 紧跟在代码之后的注释，使用 \u0026quot;//\u0026quot; 解释 * 大多数情况下，使用”//\u0026quot; 更方便 示例 /* This is the correct format for a single-line comment */\n// This is the correct format for a single-line comment\n/* * This is the correct format for a multiline comment * in a section of code. */\n// This is the correct format for a multiline comment // in a section of code.\nvar a int // this is the correct format for a // multiline comment in a declaration BOOL b // standard comment at the end of a line\n BAD：\n/* This is an incorrect format for a multiline comment * in a section of code.*/\nvar a int /* this is an incorrect comment format */\n 4\\. 编程实践 -------- ### 4.1 error string * {**ADVICE030**} error string 尽量使用小写字母，并且结尾不带标点符号 解释 * 因为可能 error string 会用于其它上下文中 示例 GOOD： fmt.Errorf(\u0026ldquo;something bad\u0026rdquo;)\n BAD： fmt.Errorf(\u0026ldquo;Something bad\u0026rdquo;)\n ### 4.2 Don't panic * {**RULE025**} 除非出现不可恢复的程序错误，不要使用 panic，用多返回值和 error。 ### 4.3 关于 lock 的保护 * {**ADVICE031**} 如果临界区内的逻辑较复杂、无法完全避免 panic 的发生，则要求适用 defer 来调用 Unlock，即使在临界区过程中发生了 panic，也会在函数退出时调用 Unlock 释放锁 解释 * go 提供了 recover，可以对 panic 进行捕获，但如果 panic 发生在临界区内，则可能导致对锁的使用没有释放 * 这种情况下，即使 panic 不会导致整个程序的奔溃，也会由于” 锁不释放 “的问题而使临界区无法被后续的调用访问 示例 GOOD： func doDemo() { lock.Lock() defer lock.Unlock()\n // 访问临界区 }\n BAD: func doDemo() { lock.Lock()\n // 访问临近区\n lock.Unlock() }\n * {**ADVICE032**} 上述操作如果造成临界区扩大后，需要建立单独的一个函数访问临界区。 解释 * 对于如下的代码： 1 2 3 4 5 6 7 8 9 `func doDemo() {` `lock.Lock()` `// step1: 临界区内的操作` `lock.Unlock()` `// step2: 临界区外的操作` `}` * 如果改造为 defer 的方式，变为如下代码，实际上扩大了临界区的范围（step2 的操作也被放置在临界区了） 1 2 3 4 5 6 7 8 `func doDemo() {` `lock.Lock()` `defer lock.Unlock()` `// step1: 临界区内的操作` `// step2: 临界区外的操作` `}` * 需要使用单独的匿名函数，专门用于访问临界区： 1 2 3 4 5 6 7 8 9 10 11 `func doDemo() {` `func() {` `lock.Lock()` `defer lock.Unlock()` `// step1: 临界区内的操作操作` `}()` `// step2: 临界区外的操作` `}` ### 4.4 日志的处理 * {**ADVICE033**} 建议使用公司 golang-lib 中的 log 库，log 库地址：[http://icode.baidu.com/repos/baidu/go-lib/log](http://icode.baidu.com/repos/baidu/go-lib/log)。 ### 4.5 unsafe package * {**ADVICE034**} 除非特殊原因，不建议使用 unsafe package * 比如进行指针和数值 uintptr 之间转换就是一个特殊原因"});index.add({'id':2,'href':'/study-go/docs/basic/grammar/','title':"第一章 Go 基本语法",'content':""});index.add({'id':3,'href':'/study-go/docs/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':4,'href':'/study-go/docs/basic/practice/spec/','title':"编程规范",'content':"Go 编程规范 "});index.add({'id':5,'href':'/study-go/docs/basic/grammar/datastruct/','title':"1.2 数据结构",'content':"Go 语言数据结构 字符串 数组 切片 哈希表 "});index.add({'id':6,'href':'/study-go/docs/basic/practice/package/','title':"Go 常用 package",'content':"Go 常用 package web gorilla / mux A powerful HTTP router and URL matcher for building Go web servers with 🦍\n"});index.add({'id':7,'href':'/study-go/docs/design/','title':"第二部分 设计",'content':""});index.add({'id':8,'href':'/study-go/docs/appendix/interview/','title':"面试题",'content':"Go 语言面试题 基础题 进阶题 高阶题 "});index.add({'id':9,'href':'/study-go/docs/source/','title':"第三部分 源码实现",'content':""});index.add({'id':10,'href':'/study-go/docs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':11,'href':'/study-go/docs/basic/practice/','title':"最佳实践",'content':"Go 最佳实践 "});index.add({'id':12,'href':'/study-go/categories/','title':"Categories",'content':""});index.add({'id':13,'href':'/study-go/docs/','title':"Docs",'content':""});index.add({'id':14,'href':'/study-go/tags/','title':"Tags",'content':""});index.add({'id':15,'href':'/study-go/','title':"首页",'content':""});})();
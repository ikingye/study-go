<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>实践 on Go 学习笔记</title>
    <link>https://ikingye.github.io/study-go/docs/basic/practice/</link>
    <description>Recent content in 实践 on Go 学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://ikingye.github.io/study-go/docs/basic/practice/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go 命令</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/command/</guid>
      <description>Go 命令 go get 等于 go get -d 加 go install
go get -d 只下载不安装 -u 强制使用网络去更新包和它的依赖包 -f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用 -v 显示执行的命令 -t 同时也下载需要为运行测试所需要的包 -fix 在获取源码之后先运行 fix，然后再去做其他的事情 -insecure 允许使用不安全的 HTTP 方式进行下载操作 go get 后面不带参数时  go get 等同于 go install go get -d 等同于 go list  参考：
 What is the difference between go get and go install?   go install  第一步是生成结果文件（可执行文件或者 .</description>
    </item>
    
    <item>
      <title>包管理</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/package-manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/package-manage/</guid>
      <description>包管理 vendor modules GO111MODULE 为 on 使用 modules 功能，这种模式下，$GOPATH 不再作为 build 时导入的角色， 依赖包会存放在 $GOPATH/pkg/mod 目录下。
GO111MODULE 为 off  优先使用 vendor 目录下面的包， 如果 vendor 下面没有搜索到，再搜索 $GOPATH/src 下面的包， 如果 $GOPATH 下面没有搜索到，那么搜索 $GOROOT/src 下面的包  </description>
    </item>
    
    <item>
      <title>编译</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/compile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/compile/</guid>
      <description>编译 交叉编译 golang 交叉编译很简单的，只要设置几个环境变量就可以了
# mac上编译linux和windows二进制 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # linux上编译mac和windows二进制 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # windows上编译mac和linux二进制 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go </description>
    </item>
    
    <item>
      <title>日志</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/log/</guid>
      <description>Go 日志 开源实现 sirupsen/logrus  Structured, pluggable logging for Go.
golang/glog  Leveled execution logs for Go</description>
    </item>
    
    <item>
      <title>最佳实践</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/best/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/best/</guid>
      <description>Go 最佳实践 </description>
    </item>
    
    <item>
      <title>测试</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/test/</guid>
      <description>Go 测试 开源实现 onsi/ginkgo  BDD Testing Framework for Go</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>1.1 语法 on Go 学习笔记</title>
    <link>https://ikingye.github.io/study-go/docs/basic/grammar/</link>
    <description>Recent content in 1.1 语法 on Go 学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://ikingye.github.io/study-go/docs/basic/grammar/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go 快速上手</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/quick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/quick/</guid>
      <description>Go 快速上手 Go 环境 GOROOT GOROOT: 指定安装 GO 的根目录
Go 1.0 之后，go tool 利用 GOROOT 查找 Go 编译器（保存在 $GOROOT/pkg/tool/$GOOS_$GOARCH） 和标准库（在 $GOROOT/pkg/$GOOS_$GOARCH）
可以将 GOROOT 理解为 Java 的 JAVA_HOME。
我们不应该设置 GOROOT，是因为 Go 工具链已经内置了正确的值。 除非：
 如果你是 Linux、FreeBSD 或者 OS X 用户，下载了 zip 和 tarball 的二进制包安装环境。这些二进制的默认环境位于 /usr/local/go，建议你将 Go 安装到这个位置。如果选择不这么做，就必须设置到你指定的目录下。 如果你是 Windows 用户，使用 zip 二进制包安装，默认的 GOROOT 在 C:\Go 目录下。如果你将 Go 安装在其他位置，请设置 GOROOT 到指定的目录。  GOPATH GOPATH: go 包的位置
GOOS vs GOARCH 随着 go tool 的引入，Go 1.</description>
    </item>
    
    <item>
      <title>defer</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/defer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/defer/</guid>
      <description>defer 用于确保程序在执行完成后，会调用某个函数，一般是执行清理工作。
Defer 的用途跟其他语言的 ensure 或 finally 类似。
当 defer 释放锁遇到尾递归 var mut = sync.Mutex{} func tailRec(i int) int { mut.Lock() // 加锁  defer mut.Unlock() // defer 释放锁  if i == 10 { return i } i++ return tailRec(i) // return 尾递归 } 以上代码执行会发生死锁，原因是 return 语句后的命令先执行，赋值给匿名返回值后，再调用 defer， 因此尾递归中 tailRec 的加锁会在 defer 释放锁之前进行，形成死锁。
根因是 golang 处理 defer 和 return 的顺序为， 计算 return 语句的返回值、赋值给匿名 / 有名返回值 -&amp;gt;defer-&amp;gt;RET 退出函数</description>
    </item>
    
    <item>
      <title>error</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/error/</guid>
      <description>error 实现 Error() string 方法的类型，都是 error 类型
type error interface { Error() string } errors.New(&amp;#34;xxxx&amp;#34;) fmt.Errorf(format string, a ...interface{}) </description>
    </item>
    
    <item>
      <title>关键字</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/keyword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/keyword/</guid>
      <description>Go 语言关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var for 与 range select defer panic 与 recover make 与 new </description>
    </item>
    
    <item>
      <title>格式化输出</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/format/</guid>
      <description>格式化输出 // Go 提供了一些用于格式化常规值的打印“动词”。 // 例如，这样打印 `point` 结构体的实例。 p := point{1, 2} fmt.Printf(&amp;#34;%v\n&amp;#34;, p) // 如果值是一个结构体，`%+v` 的格式化输出内容将包括结构体的字段名。 fmt.Printf(&amp;#34;%+v\n&amp;#34;, p) // `%#v` 根据 Go 语法输出值，即会产生该值的源码片段。 fmt.Printf(&amp;#34;%#v\n&amp;#34;, p) // 需要打印值的类型，使用 `%T`。 fmt.Printf(&amp;#34;%T\n&amp;#34;, p) // 格式化布尔值很简单。 fmt.Printf(&amp;#34;%t\n&amp;#34;, true) // 格式化整型数有多种方式，使用 `%d` 进行标准的十进制格式化。 fmt.Printf(&amp;#34;%d\n&amp;#34;, 123) // 这个输出二进制表示形式。 fmt.Printf(&amp;#34;%b\n&amp;#34;, 14) // 输出给定整数的对应字符。 fmt.Printf(&amp;#34;%c\n&amp;#34;, 33) // `%x` 提供了十六进制编码。 fmt.Printf(&amp;#34;%x\n&amp;#34;, 456) // 同样的，也为浮点型提供了多种格式化选项。 // 使用 `%f` 进行最基本的十进制格式化。 fmt.Printf(&amp;#34;%f\n&amp;#34;, 78.9) // `%e` 和 `%E` 将浮点型格式化为（稍微有一点不同的）科学记数法表示形式。 fmt.Printf(&amp;#34;%e\n&amp;#34;, 123400000.0) fmt.Printf(&amp;#34;%E\n&amp;#34;, 123400000.</description>
    </item>
    
    <item>
      <title>make</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/make/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/make/</guid>
      <description>make 运算符:= 是 make() 的语法糖</description>
    </item>
    
    <item>
      <title>select</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/select/</guid>
      <description>select Go 的 选择器（select） 让你可以同时等待多个通道操作。
将协程、通道和选择器结合，是 Go 的一个强大特性。
// 在这个例子中，我们将从两个通道中选择。 c1 := make(chan string) c2 := make(chan string) // 各个通道将在一定时间后接收一个值， // 通过这种方式来模拟并行的协程执行（例如，RPC 操作）时造成的阻塞（耗时）。 go func() { time.Sleep(1 * time.Second) c1 &amp;lt;- &amp;#34;one&amp;#34; }() go func() { time.Sleep(2 * time.Second) c2 &amp;lt;- &amp;#34;two&amp;#34; }() // 我们使用 `select` 关键字来同时等待这两个值， // 并打印各自接收到的值。 for i := 0; i &amp;lt; 2; i++ { select { case msg1 := &amp;lt;-c1: fmt.Println(&amp;#34;received&amp;#34;, msg1) case msg2 := &amp;lt;-c2: fmt.</description>
    </item>
    
    <item>
      <title>goroutine</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/goroutine/</guid>
      <description>goroutine golang 并发模型 goroutine 记得 return 或者中断，不然容易造成 goroutine 占用大量 CPU </description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>1.2 标准库 on Go 学习笔记</title><link>https://kingye.me/study-go/docs/basic/std/</link><description>Recent content in 1.2 标准库 on Go 学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/study-go/docs/basic/std/index.xml" rel="self" type="application/rss+xml"/><item><title>sort</title><link>https://kingye.me/study-go/docs/basic/std/sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/sort/</guid><description>&lt;h1 id="sort">
 sort
 &lt;a class="anchor" href="#sort">#&lt;/a>
&lt;/h1>
&lt;h2 id="自定义排序">
 自定义排序
 &lt;a class="anchor" href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%8e%92%e5%ba%8f">#&lt;/a>
&lt;/h2>
&lt;p>实现 &lt;code>Len&lt;/code>、&lt;code>Less&lt;/code> 和 &lt;code>Swap&lt;/code> 方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 有时候，我们可能想根据自然顺序以外的方式来对集合进行排序。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 例如，假设我们要按字符串的长度而不是按字母顺序对它们进行排序。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这儿有一个在 Go 中自定义排序的示例。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#e6db74">&amp;#34;sort&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 我们在这里创建了一个 `byLength` 类型，它只是内建类型 `[]string` 的别名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">byLength&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 我们为该类型实现了 `sort.Interface` 接口的 `Len`、`Less` 和 `Swap` 方法，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这样我们就可以使用 `sort` 包的通用 `Sort` 方法了，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// `Len` 和 `Swap` 在各个类型中的实现都差不多，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// `Less` 将控制实际的自定义排序逻辑。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在这个的例子中，我们想按字符串长度递增的顺序来排序，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 所以这里使用了 `len(s[i])` 和 `len(s[j])` 来实现 `Less`。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#a6e22e">byLength&lt;/span>) &lt;span style="color:#a6e22e">Len&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> len(&lt;span style="color:#a6e22e">s&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#a6e22e">byLength&lt;/span>) &lt;span style="color:#a6e22e">Swap&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>], &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>] = &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>], &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#a6e22e">byLength&lt;/span>) &lt;span style="color:#a6e22e">Less&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> len(&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]) &amp;lt; len(&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一切准备就绪后，我们就可以通过将切片 `fruits` 强转为 `byLength` 类型的切片，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 然后对该切片使用 `sort.Sort` 来实现自定义排序。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">fruits&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;peach&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;banana&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;kiwi&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Sort&lt;/span>(&lt;span style="color:#a6e22e">byLength&lt;/span>(&lt;span style="color:#a6e22e">fruits&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">fruits&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>context</title><link>https://kingye.me/study-go/docs/basic/std/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/context/</guid><description>&lt;h1 id="context">
 context
 &lt;a class="anchor" href="#context">#&lt;/a>
&lt;/h1>
&lt;h2 id="contextcontext">
 context.Context
 &lt;a class="anchor" href="#contextcontext">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>在 Goroutine 构成的树形结构中&lt;strong>对信号进行同步&lt;/strong>以减少计算资源的浪费是 context.Context 的最大作用。&lt;/li>
&lt;li>我们可能会创建多个 Goroutine 来处理&lt;strong>一次请求&lt;/strong>，而 context.Context 的作用就是在不同 Goroutine 之间同步
&lt;ul>
&lt;li>请求特定数据&lt;/li>
&lt;li>取消信号&lt;/li>
&lt;li>处理请求的截止时间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多个 Goroutine 同时订阅 &lt;code>ctx.Done()&lt;/code> 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154">context.Context&lt;/a> 是 Go 语言在 1.7 版本中引入标准库的接口 1，该接口定义了四个需要实现的方法，其中包括：&lt;/p>
&lt;ul>
&lt;li>Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期；&lt;/li>
&lt;li>Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个 Channel；&lt;/li>
&lt;li>Err — 返回 context.Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值；
&lt;ul>
&lt;li>如果 context.Context 被取消，会返回 &lt;code>Canceled&lt;/code> 错误；&lt;/li>
&lt;li>如果 context.Context 超时，会返回 &lt;code>DeadlineExceeded&lt;/code> 错误；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Context&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">Deadline&lt;/span>() (&lt;span style="color:#a6e22e">deadline&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">Done&lt;/span>() &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">Err&lt;/span>() &lt;span style="color:#66d9ef">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">Value&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#66d9ef">interface&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;code>func Background() Context&lt;/code>&lt;/li>
&lt;li>&lt;code>func TODO() Context&lt;/code>&lt;/li>
&lt;li>&lt;code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)&lt;/code>&lt;/li>
&lt;li>&lt;code>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)&lt;/code>&lt;/li>
&lt;li>&lt;code>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)&lt;/code>&lt;/li>
&lt;li>&lt;code>func WithValue(parent Context, key, val interface{}) Context&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200728110757.png" alt="" />&lt;/p></description></item><item><title>格式化输出</title><link>https://kingye.me/study-go/docs/basic/std/format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/format/</guid><description>&lt;h1 id="格式化输出">
 格式化输出
 &lt;a class="anchor" href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%be%93%e5%87%ba">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Go 提供了一些用于格式化常规值的打印“动词”。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 例如，这样打印 `point` 结构体的实例。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">point&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果值是一个结构体，`%+v` 的格式化输出内容将包括结构体的字段名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%+v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// `%#v` 根据 Go 语法输出值，即会产生该值的源码片段。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%#v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 需要打印值的类型，使用 `%T`。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%T\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 格式化布尔值很简单。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%t\n&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 格式化整型数有多种方式，使用 `%d` 进行标准的十进制格式化。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">123&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// +123 (输出符号)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%+d\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">123&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这个输出二进制表示形式。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%b\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">14&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 输出给定整数的对应字符。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%c\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">33&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// `%x` 提供了十六进制编码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%x\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">456&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 同样的，也为浮点型提供了多种格式化选项。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用 `%f` 进行最基本的十进制格式化。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%f\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">78.9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// `%e` 和 `%E` 将浮点型格式化为（稍微有一点不同的）科学记数法表示形式。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%e\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">123400000.0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%E\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">123400000.0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用 `%s` 进行基本的字符串输出。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%s\n&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;\&amp;#34;string\&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 像 Go 源代码中那样带有双引号的输出，使用 `%q`。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%q\n&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;\&amp;#34;string\&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 和上面的整型数一样，`%x` 输出使用 base-16 编码的字符串，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 每个字节使用 2 个字符表示。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%x\n&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hex this&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要输出一个指针的值，使用 `%p`。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%p\n&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 格式化数字时，您经常会希望控制输出结果的宽度和精度。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要指定整数的宽度，请在动词 &amp;#34;%&amp;#34; 之后使用数字。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 默认情况下，结果会右对齐并用空格填充。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;|%6d|%6d|\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">345&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 你也可以指定浮点型的输出宽度，同时也可以通过 `宽度.精度` 的语法来指定输出的精度。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;|%6.2f|%6.2f|\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1.2&lt;/span>, &lt;span style="color:#ae81ff">3.45&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要左对齐，使用 `-` 标志。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;|%-6.2f|%-6.2f|\n&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1.2&lt;/span>, &lt;span style="color:#ae81ff">3.45&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这是基本的宽度右对齐方法。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;|%6s|%6s|\n&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要左对齐，和数字一样，使用 `-` 标志。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;|%-6s|%-6s|\n&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 到目前为止，我们已经看过 `Printf` 了，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 它通过 `os.Stdout` 输出格式化的字符串。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// `Sprintf` 则格式化并返回一个字符串而没有任何输出。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a %s&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;string&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 你可以使用 `Fprintf` 来格式化并输出到 `io.Writers` 而不是 `os.Stdout`。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;an %s\n&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;error&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>io</title><link>https://kingye.me/study-go/docs/basic/std/io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/io/</guid><description>&lt;h1 id="iohttpsgolangorgpkgio">
 &lt;a href="https://golang.org/pkg/io/">io&lt;/a>
 &lt;a class="anchor" href="#iohttpsgolangorgpkgio">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>小数据量的拷贝，使用 ioutil.ReadAll 无伤大雅；&lt;/li>
&lt;li>数据量较大时，ReadAll 就是性能炸弹了，最好使用 io.Copy&lt;/li>
&lt;/ul>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://juejin.cn/post/6977640348679929886">golang 中的 ioutil.ReadAll vs io.Copy&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>net</title><link>https://kingye.me/study-go/docs/basic/std/net/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/net/</guid><description>&lt;h1 id="nethttpsgolangorgpkgnet">
 &lt;a href="https://golang.org/pkg/net/">net&lt;/a>
 &lt;a class="anchor" href="#nethttpsgolangorgpkgnet">#&lt;/a>
&lt;/h1>
&lt;h2 id="http">
 http
 &lt;a class="anchor" href="#http">#&lt;/a>
&lt;/h2>
&lt;h3 id="cgi">
 cgi
 &lt;a class="anchor" href="#cgi">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="fcgi">
 fcgi
 &lt;a class="anchor" href="#fcgi">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="httputil">
 httputil
 &lt;a class="anchor" href="#httputil">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="pprof">
 pprof
 &lt;a class="anchor" href="#pprof">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;hr>
&lt;h2 id="rpc">
 rpc
 &lt;a class="anchor" href="#rpc">#&lt;/a>
&lt;/h2>
&lt;hr>
&lt;hr>
&lt;h2 id="url">
 url
 &lt;a class="anchor" href="#url">#&lt;/a>
&lt;/h2></description></item><item><title>signal</title><link>https://kingye.me/study-go/docs/basic/std/signal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/signal/</guid><description>&lt;h1 id="signalhttpspkggodevossignal">
 &lt;a href="https://pkg.go.dev/os/signal">signal&lt;/a>
 &lt;a class="anchor" href="#signalhttpspkggodevossignal">#&lt;/a>
&lt;/h1>
&lt;p>The signals &lt;code>SIGKILL&lt;/code> and &lt;code>SIGSTOP&lt;/code> may not be caught by a program,
and therefore cannot be affected by this package.&lt;/p>
&lt;p>By default, a synchronous signal is converted into a run-time panic.&lt;/p>
&lt;p>A SIGHUP, SIGINT, or SIGTERM signal causes the program to exit.&lt;/p>
&lt;p>A SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit &lt;strong>with a stack dump&lt;/strong>.&lt;/p>
&lt;p>A SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default behavior (these signals are used by the shell for job control).&lt;/p></description></item><item><title>sync</title><link>https://kingye.me/study-go/docs/basic/std/sync/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/sync/</guid><description>&lt;h1 id="sync">
 sync
 &lt;a class="anchor" href="#sync">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>sync.Mutex&lt;/li>
&lt;li>sync.RWMutex&lt;/li>
&lt;li>sync.WaitGroup&lt;/li>
&lt;li>sync.Once&lt;/li>
&lt;li>sync.Cond&lt;/li>
&lt;/ul>
&lt;h2 id="锁的类型">
 锁的类型
 &lt;a class="anchor" href="#%e9%94%81%e7%9a%84%e7%b1%bb%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="mutex-互斥锁">
 Mutex 互斥锁
 &lt;a class="anchor" href="#mutex-%e4%ba%92%e6%96%a5%e9%94%81">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Mutex&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">sema&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span> &lt;span style="color:#75715e">// semaphore 信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>sync.Mutex.Lock 和 sync.Mutex.Unlock&lt;/li>
&lt;/ul>
&lt;h4 id="state">
 state
 &lt;a class="anchor" href="#state">#&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 8 位&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>**** ****
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>***** * * *
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>waitersCount mutexStarving mutexWoken mutexLocked
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>mutexLocked — 表示互斥锁的&lt;strong>锁定状态&lt;/strong>&lt;/li>
&lt;li>mutexWoken — 表示从正常模式被从唤醒&lt;/li>
&lt;li>mutexStarving — 当前的互斥锁进入&lt;strong>饥饿状态&lt;/strong>
&lt;ul>
&lt;li>Goroutine 超过 &lt;code>1ms&lt;/code> 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止被饿死，造成&lt;strong>高尾延时&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>waitersCount — 当前互斥锁上&lt;strong>等待&lt;/strong>的 Goroutine 个数 (最多 128 个)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="rwmutex">
 RWMutex
 &lt;a class="anchor" href="#rwmutex">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RWMutex&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">Mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">writerSem&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">readerSem&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">readerCount&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">readerWait&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>写操作使用 sync.RWMutex.Lock 和 sync.RWMutex.Unlock 方法；&lt;/li>
&lt;li>读操作使用 sync.RWMutex.RLock 和 sync.RWMutex.RUnlock 方法；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>调用 &lt;code>sync.RWMutex.Lock&lt;/code> 尝试获取写锁时；
&lt;ul>
&lt;li>每次 &lt;code>sync.RWMutex.RUnlock&lt;/code> 都会将 readerWait 其减一，当它归零时该 Goroutine 就会获得写锁；&lt;/li>
&lt;li>将 readerCount 减少 rwmutexMaxReaders 个数以阻塞后续的读操作；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>调用 &lt;code>sync.RWMutex.Unlock&lt;/code> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；&lt;/li>
&lt;/ul>
&lt;p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。&lt;/p></description></item><item><title>time</title><link>https://kingye.me/study-go/docs/basic/std/strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/strings/</guid><description>&lt;h1 id="timehttpspkggodevtime">
 &lt;a href="https://pkg.go.dev/time">time&lt;/a>
 &lt;a class="anchor" href="#timehttpspkggodevtime">#&lt;/a>
&lt;/h1>
&lt;h2 id="格式化">
 格式化
 &lt;a class="anchor" href="#%e6%a0%bc%e5%bc%8f%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1 2 3 4 5 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">ANSIC&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;Mon Jan _2 15:04:05 2006&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>().&lt;span style="color:#a6e22e">Format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;2006-01-02 15:04:05&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>time</title><link>https://kingye.me/study-go/docs/basic/std/time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/std/time/</guid><description>&lt;h1 id="timehttpspkggodevtime">
 &lt;a href="https://pkg.go.dev/time">time&lt;/a>
 &lt;a class="anchor" href="#timehttpspkggodevtime">#&lt;/a>
&lt;/h1>
&lt;h2 id="格式化">
 格式化
 &lt;a class="anchor" href="#%e6%a0%bc%e5%bc%8f%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1 2 3 4 5 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">ANSIC&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;Mon Jan _2 15:04:05 2006&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>().&lt;span style="color:#a6e22e">Unix&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>().&lt;span style="color:#a6e22e">Format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;2006-01-02 15:04:05&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>
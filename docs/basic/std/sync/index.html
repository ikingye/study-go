<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.140.1"><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  sync
  #


sync.Mutex
sync.RWMutex
sync.WaitGroup
sync.Once
sync.Cond


  锁的类型
  #


  Mutex 互斥锁
  #

type Mutex struct {
	state int32
	sema  uint32 // semaphore 信号量
}

sync.Mutex.Lock 和 sync.Mutex.Unlock


  state
  #

# 8 位
**** ****

*****               *              *           *
waitersCount  mutexStarving   mutexWoken   mutexLocked

mutexLocked — 表示互斥锁的锁定状态
mutexWoken — 表示从正常模式被从唤醒
mutexStarving — 当前的互斥锁进入饥饿状态

Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止被饿死，造成高尾延时


waitersCount — 当前互斥锁上等待的 Goroutine 个数 (最多 128 个)



  RWMutex
  #

type RWMutex struct {
	w           Mutex
	writerSem   uint32
	readerSem   uint32
	readerCount int32
	readerWait  int32
}

写操作使用 sync.RWMutex.Lock 和 sync.RWMutex.Unlock 方法；
读操作使用 sync.RWMutex.RLock 和 sync.RWMutex.RUnlock 方法；



调用 sync.RWMutex.Lock 尝试获取写锁时；

每次 sync.RWMutex.RUnlock 都会将 readerWait 其减一，当它归零时该 Goroutine 就会获得写锁；
将 readerCount 减少 rwmutexMaxReaders 个数以阻塞后续的读操作；


调用 sync.RWMutex.Unlock 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；

读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://kingye.me/study-go/docs/basic/std/sync/"><meta property="og:site_name" content="Go 学习笔记"><meta property="og:title" content="sync"><meta property="og:description" content="sync # sync.Mutex sync.RWMutex sync.WaitGroup sync.Once sync.Cond 锁的类型 # Mutex 互斥锁 # type Mutex struct { state int32 sema uint32 // semaphore 信号量 } sync.Mutex.Lock 和 sync.Mutex.Unlock state # # 8 位 **** **** ***** * * * waitersCount mutexStarving mutexWoken mutexLocked mutexLocked — 表示互斥锁的锁定状态 mutexWoken — 表示从正常模式被从唤醒 mutexStarving — 当前的互斥锁进入饥饿状态 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止被饿死，造成高尾延时 waitersCount — 当前互斥锁上等待的 Goroutine 个数 (最多 128 个) RWMutex # type RWMutex struct { w Mutex writerSem uint32 readerSem uint32 readerCount int32 readerWait int32 } 写操作使用 sync.RWMutex.Lock 和 sync.RWMutex.Unlock 方法； 读操作使用 sync.RWMutex.RLock 和 sync.RWMutex.RUnlock 方法； 调用 sync.RWMutex.Lock 尝试获取写锁时； 每次 sync.RWMutex.RUnlock 都会将 readerWait 其减一，当它归零时该 Goroutine 就会获得写锁； 将 readerCount 减少 rwmutexMaxReaders 个数以阻塞后续的读操作； 调用 sync.RWMutex.Unlock 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁； 读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2021-07-15T17:31:08+08:00"><title>sync | Go 学习笔记</title>
<link rel=manifest href=/study-go/manifest.json><link rel=icon href=/study-go/favicon.png><link rel=canonical href=https://kingye.me/study-go/docs/basic/std/sync/><link rel=stylesheet href=/study-go/book.min.45ab58199f84c9a33853fdef2e41664c57a49ca55c9badf2dd2dd071f39975a3.css integrity="sha256-RatYGZ+EyaM4U/3vLkFmTFeknKVcm63y3S3QcfOZdaM=" crossorigin=anonymous><script defer src=/study-go/fuse.min.js></script><script defer src=/study-go/en.search.min.cff675cc4aead4e28c4ab07c7bb96b38e51862190ef3b050a8ab95db897ae4a3.js integrity="sha256-z/Z1zErq1OKMSrB8e7lrOOUYYhkO87BQqKuV24l65KM=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/study-go/><span>Go 学习笔记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=https://kingye.me target=_blank rel="noopener noreferrer">博客</a></li><li><a href=https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200417021727.png target=_blank rel="noopener noreferrer">公众号</a></li><li><a href=https://github.com/ikingye target=_blank rel="noopener noreferrer">Github</a></li><li><a href=https://weibo.com/kingyip15215 target=_blank rel="noopener noreferrer">微博</a></li><li><a href=https://www.zhihu.com/people/wutongyip target=_blank rel="noopener noreferrer">知乎</a></li></ul><hr><ul><li><span>第一部分 基础入门</span><ul><li><input type=checkbox id=section-cf26a2b65f20aeeda3cacf0d31bc9892 class=toggle>
<label for=section-cf26a2b65f20aeeda3cacf0d31bc9892 class="flex justify-between"><a href=/study-go/docs/basic/ref/>1.1 语法</a></label><ul><li><input type=checkbox id=section-8fc4e1a169d5d1ed76d609fe243e0067 class=toggle>
<label for=section-8fc4e1a169d5d1ed76d609fe243e0067 class="flex justify-between"><a href=/study-go/docs/basic/ref/type/>1.1.1 数据类型</a></label><ul><li><input type=checkbox id=section-6995ebaf8bf7c4f4f5c2f7cbdaaa7063 class=toggle>
<label for=section-6995ebaf8bf7c4f4f5c2f7cbdaaa7063 class="flex justify-between"><a href=/study-go/docs/basic/ref/type/error/>error</a></label></li><li><a href=/study-go/docs/basic/ref/type/slice/>切片</a></li><li><a href=/study-go/docs/basic/ref/type/string/>字符串</a></li><li><a href=/study-go/docs/basic/ref/type/array/>数组</a></li><li><input type=checkbox id=section-903e200364223546b4418c02f06eb32a class=toggle>
<label for=section-903e200364223546b4418c02f06eb32a class="flex justify-between"><a href=/study-go/docs/basic/ref/type/interface/>Interface</a></label></li><li><input type=checkbox id=section-05475f39ea7acf355beffd64d6328380 class=toggle>
<label for=section-05475f39ea7acf355beffd64d6328380 class="flex justify-between"><a href=/study-go/docs/basic/ref/type/channel/>Chiannel</a></label></li><li><input type=checkbox id=section-f667d710022efdab26dd032143e13ea4 class=toggle>
<label for=section-f667d710022efdab26dd032143e13ea4 class="flex justify-between"><a href=/study-go/docs/basic/ref/type/map/>Map</a></label></li></ul></li><li><input type=checkbox id=section-b74f28be7f390435a6ddc867eda31244 class=toggle>
<label for=section-b74f28be7f390435a6ddc867eda31244 class="flex justify-between"><a href=/study-go/docs/basic/ref/keyword/>1.1.2 关键字</a></label><ul><li><input type=checkbox id=section-91ef0b916beb2e673103f21c8529d38b class=toggle>
<label for=section-91ef0b916beb2e673103f21c8529d38b class="flex justify-between"><a href=/study-go/docs/basic/ref/keyword/defer/>defer</a></label></li><li><input type=checkbox id=section-fe5d4054ab40a9388275c406bfdabef2 class=toggle>
<label for=section-fe5d4054ab40a9388275c406bfdabef2 class="flex justify-between"><a href=/study-go/docs/basic/ref/keyword/for/>for 和 range</a></label></li><li><a href=/study-go/docs/basic/ref/keyword/func/>函数</a><ul><li><input type=checkbox id=section-2b5bab33c305bc288a6ffea6baae611a class=toggle>
<label for=section-2b5bab33c305bc288a6ffea6baae611a class="flex justify-between"><a href=/study-go/docs/basic/ref/keyword/func/init/>init</a></label></li><li><a href=/study-go/docs/basic/ref/keyword/func/receiver/>Receiver</a></li></ul></li><li><input type=checkbox id=section-6e1b8572d9a7726f06aa28d12aa20cc8 class=toggle>
<label for=section-6e1b8572d9a7726f06aa28d12aa20cc8 class="flex justify-between"><a href=/study-go/docs/basic/ref/keyword/make/>make</a></label></li><li><input type=checkbox id=section-6e5b8c5cfd9952241c043eeea9146ee6 class=toggle>
<label for=section-6e5b8c5cfd9952241c043eeea9146ee6 class="flex justify-between"><a href=/study-go/docs/basic/ref/keyword/select/>select</a></label></li></ul></li></ul></li><li><input type=checkbox id=section-85397eb26451fc3d656caf9aa8eea957 class=toggle checked>
<label for=section-85397eb26451fc3d656caf9aa8eea957 class="flex justify-between"><a href=/study-go/docs/basic/std/>1.2 标准库</a></label><ul><li><input type=checkbox id=section-501293d2e27d7c8de6445498afa117ae class=toggle>
<label for=section-501293d2e27d7c8de6445498afa117ae class="flex justify-between"><a href=/study-go/docs/basic/std/sort/>sort</a></label></li><li><input type=checkbox id=section-aa776ed5233dfe83c839a82873cde28d class=toggle>
<label for=section-aa776ed5233dfe83c839a82873cde28d class="flex justify-between"><a href=/study-go/docs/basic/std/context/>context</a></label></li><li><input type=checkbox id=section-b5f0a33d9fbb59c688059280b417615e class=toggle>
<label for=section-b5f0a33d9fbb59c688059280b417615e class="flex justify-between"><a href=/study-go/docs/basic/std/format/>格式化输出</a></label></li><li><input type=checkbox id=section-858e75705b059b70b5cc0cb1a392c87c class=toggle>
<label for=section-858e75705b059b70b5cc0cb1a392c87c class="flex justify-between"><a href=/study-go/docs/basic/std/io/>io</a></label></li><li><input type=checkbox id=section-35db8cb790005717608e58bfeb15d85f class=toggle>
<label for=section-35db8cb790005717608e58bfeb15d85f class="flex justify-between"><a href=/study-go/docs/basic/std/net/>net</a></label></li><li><input type=checkbox id=section-a49267c9e55cc7ac8b97bddfbc517659 class=toggle>
<label for=section-a49267c9e55cc7ac8b97bddfbc517659 class="flex justify-between"><a href=/study-go/docs/basic/std/signal/>signal</a></label></li><li><input type=checkbox id=section-9b28a0967ba2a32d2009aafd5f5f9ad1 class=toggle checked>
<label for=section-9b28a0967ba2a32d2009aafd5f5f9ad1 class="flex justify-between"><a href=/study-go/docs/basic/std/sync/ class=active>sync</a></label></li><li><input type=checkbox id=section-740e5e0f3012abbd6afbd6c63b24b299 class=toggle>
<label for=section-740e5e0f3012abbd6afbd6c63b24b299 class="flex justify-between"><a href=/study-go/docs/basic/std/strings/>time</a></label></li><li><input type=checkbox id=section-5be4090bbd164052e09ead66e60a38ce class=toggle>
<label for=section-5be4090bbd164052e09ead66e60a38ce class="flex justify-between"><a href=/study-go/docs/basic/std/time/>time</a></label></li></ul></li><li><input type=checkbox id=section-8912eace3ae26a10ec6a7d7f77f73c95 class=toggle>
<label for=section-8912eace3ae26a10ec6a7d7f77f73c95 class="flex justify-between"><a href=/study-go/docs/basic/spec/>1.3 编程规范</a></label><ul></ul></li><li><input type=checkbox id=section-8437a105c6e7fbf77a115319ec34d2f0 class=toggle>
<label for=section-8437a105c6e7fbf77a115319ec34d2f0 class="flex justify-between"><a href=/study-go/docs/basic/others/>1.4 其他</a></label><ul><li><input type=checkbox id=section-fec70b728db077c65ab1452db2929a79 class=toggle>
<label for=section-fec70b728db077c65ab1452db2929a79 class="flex justify-between"><a href=/study-go/docs/basic/others/quick/>Go 快速上手</a></label></li><li><input type=checkbox id=section-836703fcedaa005754288a32c6d9ba6b class=toggle>
<label for=section-836703fcedaa005754288a32c6d9ba6b class="flex justify-between"><a href=/study-go/docs/basic/others/pros-and-cons/>优劣</a></label></li><li><a href=/study-go/docs/basic/others/gobuild/>Go build</a></li><li><a href=/study-go/docs/basic/others/gomod/>Go Modules</a></li><li><a href=/study-go/docs/basic/others/gopls/>gopls</a></li><li><a href=/study-go/docs/basic/others/pm/>包管理</a></li><li><a href=/study-go/docs/basic/others/compile/>编译</a></li><li><input type=checkbox id=section-7bcd44a23c5090c8cd4571cfb3a46a76 class=toggle>
<label for=section-7bcd44a23c5090c8cd4571cfb3a46a76 class="flex justify-between"><a href=/study-go/docs/basic/others/command/>Go 命令</a></label><ul><li><input type=checkbox id=section-b455fda431bf18f1c1f29ceb0e873707 class=toggle>
<label for=section-b455fda431bf18f1c1f29ceb0e873707 class="flex justify-between"><a href=/study-go/docs/basic/others/command/install/>安装</a></label></li></ul></li><li><input type=checkbox id=section-6a596f3f6f240a9312ce04a989a61a7f class=toggle>
<label for=section-6a596f3f6f240a9312ce04a989a61a7f class="flex justify-between"><a href=/study-go/docs/basic/others/history/>历史</a></label></li><li><input type=checkbox id=section-dd07e4000a7cbe35560cd5836896be98 class=toggle>
<label for=section-dd07e4000a7cbe35560cd5836896be98 class="flex justify-between"><a href=/study-go/docs/basic/others/plugin/>Go 插件系统</a></label></li><li><input type=checkbox id=section-6a97dd977285d401b99cbb086b793113 class=toggle>
<label for=section-6a97dd977285d401b99cbb086b793113 class="flex justify-between"><a href=/study-go/docs/basic/others/goroutine/>goroutine</a></label></li><li><input type=checkbox id=section-03ff83c59e29325546629824c988535d class=toggle>
<label for=section-03ff83c59e29325546629824c988535d class="flex justify-between"><a href=/study-go/docs/basic/others/version/>版本</a></label></li></ul></li></ul></li><li><span>第二部分 进阶实战</span><ul><li><input type=checkbox id=section-70922a3b1ab657008b9130da19418da8 class=toggle>
<label for=section-70922a3b1ab657008b9130da19418da8 class="flex justify-between"><a href=/study-go/docs/advanced/pattern/>2.1 设计模式</a></label><ul></ul></li><li><input type=checkbox id=section-30cd0f4cc17fdb0776ce429cc199abfa class=toggle>
<label for=section-30cd0f4cc17fdb0776ce429cc199abfa class="flex justify-between"><a href=/study-go/docs/advanced/algs/>2.2 算法实现</a></label><ul></ul></li><li><input type=checkbox id=section-3407c0075d7e1358acc2b8d2cd4ee640 class=toggle>
<label for=section-3407c0075d7e1358acc2b8d2cd4ee640 class="flex justify-between"><a href=/study-go/docs/advanced/pkg/>2.3 常用库</a></label><ul><li><input type=checkbox id=section-8e56e3a4b42ca5c1a9641c14b3e3d168 class=toggle>
<label for=section-8e56e3a4b42ca5c1a9641c14b3e3d168 class="flex justify-between"><a href=/study-go/docs/advanced/pkg/cobra/>cobra</a></label></li><li><input type=checkbox id=section-b208f828541038f587faae823e932095 class=toggle>
<label for=section-b208f828541038f587faae823e932095 class="flex justify-between"><a href=/study-go/docs/advanced/pkg/klog/>klog</a></label></li></ul></li><li><input type=checkbox id=section-f823e7e1e006aeb718633221b06f9b6d class=toggle>
<label for=section-f823e7e1e006aeb718633221b06f9b6d class="flex justify-between"><a href=/study-go/docs/advanced/snippet/>2.4 代码片段</a></label><ul></ul></li><li><input type=checkbox id=section-7de94f625308567b0f182d7cf38f991a class=toggle>
<label for=section-7de94f625308567b0f182d7cf38f991a class="flex justify-between"><a href=/study-go/docs/advanced/test/>2.5 测试</a></label><ul></ul></li><li><input type=checkbox id=section-855b28cf7ef76983806d5c935a56d1ab class=toggle>
<label for=section-855b28cf7ef76983806d5c935a56d1ab class="flex justify-between"><a href=/study-go/docs/advanced/prof/>2.6 性能</a></label><ul></ul></li><li><input type=checkbox id=section-52bf9c0157813674b548f1bce7bcdb36 class=toggle>
<label for=section-52bf9c0157813674b548f1bce7bcdb36 class="flex justify-between"><a href=/study-go/docs/advanced/frame/>2.7 框架</a></label><ul><li><input type=checkbox id=section-0b43069f47deae14e320f38cab0ec6ae class=toggle>
<label for=section-0b43069f47deae14e320f38cab0ec6ae class="flex justify-between"><a href=/study-go/docs/advanced/frame/beego/>Beego</a></label><ul></ul></li></ul></li></ul></li><li><span>第三部分 设计与实现</span><ul><li><input type=checkbox id=section-5d55dfdebbda4ae0010fc4951ce81e7f class=toggle>
<label for=section-5d55dfdebbda4ae0010fc4951ce81e7f class="flex justify-between"><a href=/study-go/docs/design/type/>3.1 数据类型</a></label><ul><li><input type=checkbox id=section-ea1e6ba0016587050d8e7571c5aa9ab0 class=toggle>
<label for=section-ea1e6ba0016587050d8e7571c5aa9ab0 class="flex justify-between"><a href=/study-go/docs/design/type/type/>类型系统</a></label></li></ul></li><li><input type=checkbox id=section-d769b31c004a8a420e09e8207d350c86 class=toggle>
<label for=section-d769b31c004a8a420e09e8207d350c86 class="flex justify-between"><a href=/study-go/docs/design/keyword/>3.2 关键字</a></label><ul><li><input type=checkbox id=section-f64c3a979d0515a193bd91464ad97bd7 class=toggle>
<label for=section-f64c3a979d0515a193bd91464ad97bd7 class="flex justify-between"><a href=/study-go/docs/design/keyword/interface/>interface</a></label></li></ul></li><li><input type=checkbox id=section-ebca84eadd201ae9c1d26f2472564746 class=toggle>
<label for=section-ebca84eadd201ae9c1d26f2472564746 class="flex justify-between"><a href=/study-go/docs/design/runtime/>3.3 运行时</a></label><ul><li><input type=checkbox id=section-15069cec777c6e5c864e9ce29658240c class=toggle>
<label for=section-15069cec777c6e5c864e9ce29658240c class="flex justify-between"><a href=/study-go/docs/design/runtime/init/>Go 初始化</a></label></li><li><input type=checkbox id=section-e52f9b3f06eae4470b308876fedb24c6 class=toggle>
<label for=section-e52f9b3f06eae4470b308876fedb24c6 class="flex justify-between"><a href=/study-go/docs/design/runtime/scheduling/>Go 调度</a></label></li><li><input type=checkbox id=section-7bf7fa5ee04ceb63938717a3b17cd2e7 class=toggle>
<label for=section-7bf7fa5ee04ceb63938717a3b17cd2e7 class="flex justify-between"><a href=/study-go/docs/design/runtime/gc/>GC</a></label></li><li><input type=checkbox id=section-4f0ffaafba38159272629206bdb4b5bc class=toggle>
<label for=section-4f0ffaafba38159272629206bdb4b5bc class="flex justify-between"><a href=/study-go/docs/design/runtime/concurrent/>并发</a></label></li></ul></li><li><a href=/study-go/docs/design/code/>3.7 源码分析</a><ul><li><input type=checkbox id=section-5aa83432328c738e4a45003c577aa54d class=toggle>
<label for=section-5aa83432328c738e4a45003c577aa54d class="flex justify-between"><a href=/study-go/docs/design/code/1.0.0/>1.0.0</a></label><ul></ul></li><li><input type=checkbox id=section-3c8139a2e506f7115d19c36cfe592298 class=toggle>
<label for=section-3c8139a2e506f7115d19c36cfe592298 class="flex justify-between"><a href=/study-go/docs/design/code/1.5.0/>1.5.0</a></label><ul></ul></li></ul></li></ul></li><li><span>第四部分 附录</span><ul><li><input type=checkbox id=section-a07fef98452506b80b867d121d3a2164 class=toggle>
<label for=section-a07fef98452506b80b867d121d3a2164 class="flex justify-between"><a href=/study-go/docs/appendix/tutorial/>4.1 教程</a></label></li><li><input type=checkbox id=section-4b89657782ab0cb5c9404691f696e2a4 class=toggle>
<label for=section-4b89657782ab0cb5c9404691f696e2a4 class="flex justify-between"><a href=/study-go/docs/appendix/interview/>4.2 面试题</a></label></li><li><input type=checkbox id=section-f71a573a8e93fb879a514522fb08b820 class=toggle>
<label for=section-f71a573a8e93fb879a514522fb08b820 class="flex justify-between"><a href=/study-go/docs/appendix/attention/>4.3 关注项目</a></label></li><li><input type=checkbox id=section-109ca1f1db2d61fab34851e9ec713995 class=toggle>
<label for=section-109ca1f1db2d61fab34851e9ec713995 class="flex justify-between"><a href=/study-go/docs/appendix/gossip/>4.4 一些八卦</a></label></li></ul></li></ul><hr><ul><li><a href=https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200417022040.png target=_blank rel="noopener noreferrer">微信</a></li><li><a href="https://qm.qq.com/cgi-bin/qm/qr?k=EUhzg0UwUksxpQnwEmPngRLezlC6qrnn&jump_from=webapi" target=_blank rel="noopener noreferrer"><img src=//pub.idqqimg.com/wpa/images/group.png></a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/study-go/svg/menu.svg class=book-icon alt=Menu>
</label><strong>sync</strong>
<label for=toc-control><img src=/study-go/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#锁的类型>锁的类型</a><ul><li><a href=#mutex-互斥锁>Mutex 互斥锁</a><ul><li><a href=#state>state</a></li></ul></li><li><a href=#rwmutex>RWMutex</a></li><li><a href=#waitgroup>WaitGroup</a><ul><li><a href=#done>Done</a></li></ul></li><li><a href=#once>Once</a></li><li><a href=#cond>Cond</a></li></ul></li><li><a href=#mutex>Mutex</a><ul><li><a href=#mutex-互斥锁-1>Mutex 互斥锁</a></li><li><a href=#rwmutex-读写锁读多写少>RWMutex 读写锁（读多写少）</a></li></ul></li><li><a href=#cond-1>Cond</a><ul><li><a href=#synccond-vs-syncmutex><code>sync.Cond</code> vs <code>sync.Mutex</code></a></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></aside></header><article id=article class=markdown><h1 id=sync>sync
<a class=anchor href=#sync>#</a></h1><ul><li>sync.Mutex</li><li>sync.RWMutex</li><li>sync.WaitGroup</li><li>sync.Once</li><li>sync.Cond</li></ul><h2 id=锁的类型>锁的类型
<a class=anchor href=#%e9%94%81%e7%9a%84%e7%b1%bb%e5%9e%8b>#</a></h2><h3 id=mutex-互斥锁>Mutex 互斥锁
<a class=anchor href=#mutex-%e4%ba%92%e6%96%a5%e9%94%81>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Mutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>state</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sema</span>  <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// semaphore 信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>sync.Mutex.Lock 和 sync.Mutex.Unlock</li></ul><h4 id=state>state
<a class=anchor href=#state>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 8 位</span>
</span></span><span style=display:flex><span>**** ****
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>*****               *              *           *
</span></span><span style=display:flex><span>waitersCount  mutexStarving   mutexWoken   mutexLocked
</span></span></code></pre></div><ul><li>mutexLocked — 表示互斥锁的<strong>锁定状态</strong></li><li>mutexWoken — 表示从正常模式被从唤醒</li><li>mutexStarving — 当前的互斥锁进入<strong>饥饿状态</strong><ul><li>Goroutine 超过 <code>1ms</code> 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止被饿死，造成<strong>高尾延时</strong></li></ul></li><li>waitersCount — 当前互斥锁上<strong>等待</strong>的 Goroutine 个数 (最多 128 个)</li></ul><hr><h3 id=rwmutex>RWMutex
<a class=anchor href=#rwmutex>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RWMutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>w</span>           <span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>writerSem</span>   <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>readerSem</span>   <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>readerCount</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>readerWait</span>  <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>写操作使用 sync.RWMutex.Lock 和 sync.RWMutex.Unlock 方法；</li><li>读操作使用 sync.RWMutex.RLock 和 sync.RWMutex.RUnlock 方法；</li></ul><hr><ul><li>调用 <code>sync.RWMutex.Lock</code> 尝试获取写锁时；<ul><li>每次 <code>sync.RWMutex.RUnlock</code> 都会将 readerWait 其减一，当它归零时该 Goroutine 就会获得写锁；</li><li>将 readerCount 减少 rwmutexMaxReaders 个数以阻塞后续的读操作；</li></ul></li><li>调用 <code>sync.RWMutex.Unlock</code> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li></ul><p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p><hr><h3 id=waitgroup>WaitGroup
<a class=anchor href=#waitgroup>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WaitGroup</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>noCopy</span> <span style=color:#a6e22e>noCopy</span> <span style=color:#75715e>// wg 无法复制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>state1</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>requests</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>{<span style=color:#f92672>...</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
</span></span><span style=display:flex><span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(len(<span style=color:#a6e22e>requests</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>request</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>requests</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// res, err := service.call(r)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }(<span style=color:#a6e22e>request</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span></code></pre></div><h4 id=done>Done
<a class=anchor href=#done>#</a></h4><p>sync.WaitGroup.Done 只是对 sync.WaitGroup.Add 方法的简单封装，
我们可以向 sync.WaitGroup.Add 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；</p><hr><h3 id=once>Once
<a class=anchor href=#once>#</a></h3><ul><li>sync.Once.Do 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li><li>两次调用 sync.Once.Do 方法传入不同的函数也只会<strong>执行第一次调用</strong>的函数；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Once</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span>    <span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=cond>Cond
<a class=anchor href=#cond>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Cond</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>L</span>       <span style=color:#a6e22e>Locker</span> <span style=color:#75715e>// 用于保护内部的 notify 字段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>notify</span>  <span style=color:#a6e22e>notifyList</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>noCopy</span>  <span style=color:#a6e22e>noCopy</span> <span style=color:#75715e>// 保证结构体不会在编译期间拷贝
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>checker</span> <span style=color:#a6e22e>copyChecker</span> <span style=color:#75715e>// 禁止运行期间发生的拷贝
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>notifyList</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wait</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>notify</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>head</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tail</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><ul><li>sync.Cond.Wait 将当前 Goroutine 陷入休眠状态<ul><li>在调用之前一定要使用获取互斥锁，否则会触发程序崩溃</li></ul></li><li>sync.Cond.Signal 唤醒队列最前面的 Goroutine</li><li>sync.Cond.Broadcast 唤醒队列中全部的 Goroutine</li></ul><hr><hr><h2 id=mutex>Mutex
<a class=anchor href=#mutex>#</a></h2><h3 id=mutex-互斥锁-1>Mutex 互斥锁
<a class=anchor href=#mutex-%e4%ba%92%e6%96%a5%e9%94%81-1>#</a></h3><ul><li>在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex</li><li>使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁<ul><li>在<strong>同一个 goroutine</strong> 中的 Mutex 解锁之前再次进行加锁，会导致死锁</li></ul></li><li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li><li>已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁</li><li>适用于读写不确定，并且只有一个读或者写的场景</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Mutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// contains filtered or unexported fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>) <span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>) <span style=color:#a6e22e>Unlock</span>()
</span></span></code></pre></div><h3 id=rwmutex-读写锁读多写少>RWMutex 读写锁（读多写少）
<a class=anchor href=#rwmutex-%e8%af%bb%e5%86%99%e9%94%81%e8%af%bb%e5%a4%9a%e5%86%99%e5%b0%91>#</a></h3><p>RWMutex 基于 Mutex 实现</p><ul><li>RWMutex 是单写多读锁，该锁可以加一个写锁或者多个读锁</li><li>写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占<ul><li>Lock() 加写锁，Unlock() 解写锁</li><li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li><li>如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即<strong>写锁权限高于读锁</strong>，有写锁时优先进行写锁定</li></ul></li><li>读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁<ul><li>RLock() 加读锁，RUnlock() 解读锁</li><li>RLock() 加读锁时，如果存在写锁，则无法加读锁</li><li>在没有读锁的情况下调用 RUnlock() 会导致 panic 错误<ul><li>RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误</li></ul></li></ul></li><li>适用于<strong>读多写少</strong>的场景</li></ul><hr><hr><h2 id=cond-1>Cond
<a class=anchor href=#cond-1>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Cond</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// L is held while observing or changing the condition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>L</span> <span style=color:#a6e22e>Locker</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// contains filtered or unexported fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Broadcast 会唤醒所有等待 c 的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Broadcast</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Signal 只唤醒 1 个等待 c 的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Signal</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Wait() 会自动释放 c.L，并挂起调用者的 goroutine。之后恢复执行，Wait() 会在返回时对 c.L 加锁。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 除非被 Signal 或者 Broadcast 唤醒，否则 Wait() 不会返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Wait</span>()
</span></span></code></pre></div><ul><li>条件<ul><li>一个条件一定要有一个信号</li></ul></li><li>信号<ul><li>wait 等待的是信号</li><li>signal 发送的是信号</li><li>一个信号可以对应到<em>多个条件</em></li></ul></li></ul><h3 id=synccond-vs-syncmutex><code>sync.Cond</code> vs <code>sync.Mutex</code>
<a class=anchor href=#synccond-vs-syncmutex>#</a></h3><ul><li>Mutex<ul><li>one goroutine for each write and read</li></ul></li><li>Cond<ul><li>multiple readers wait for the shared resources to be available</li></ul></li></ul><hr><h3 id=参考>参考
<a class=anchor href=#%e5%8f%82%e8%80%83>#</a></h3><ul><li><a href=https://stackoverflow.com/questions/36857167/how-to-correctly-use-sync-cond>How to correctly use sync.Cond?</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/ikingye/study-go/commit/9830af3ae9ccdb1cec4ee3dd063dbccbcfc43feb title='Last modified by yewang | 2021-07-15' target=_blank rel=noopener><img src=/study-go/svg/calendar.svg class=book-icon alt>
<span>2021-07-15</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div><br><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link rel=stylesheet href=//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css><p><span id=busuanzi_container_page_pv>本文访问量 <span id=busuanzi_value_page_pv><i class="fa fa-spinner fa-spin"></i></span> 次</span></p><p><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><i class="fa fa-spinner fa-spin"></i></span> 次</span></p><p><span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><i class="fa fa-spinner fa-spin"></i></span> 人</span></p></div></footer><div class=book-comments><script src=https://utteranc.es/client.js repo=ikingye/study-go issue-term=pathname theme=github-light crossorigin=anonymous async></script><div id=footer><p><a href=https://kingye.me>叶王</a> &copy; 2013-2024
版权所有。如果本文档对你有所帮助，可以<a href=https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200428110046.png target=_blank rel="noopener noreferrer">请作者喝饮料</a>。</p></div></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#锁的类型>锁的类型</a><ul><li><a href=#mutex-互斥锁>Mutex 互斥锁</a><ul><li><a href=#state>state</a></li></ul></li><li><a href=#rwmutex>RWMutex</a></li><li><a href=#waitgroup>WaitGroup</a><ul><li><a href=#done>Done</a></li></ul></li><li><a href=#once>Once</a></li><li><a href=#cond>Cond</a></li></ul></li><li><a href=#mutex>Mutex</a><ul><li><a href=#mutex-互斥锁-1>Mutex 互斥锁</a></li><li><a href=#rwmutex-读写锁读多写少>RWMutex 读写锁（读多写少）</a></li></ul></li><li><a href=#cond-1>Cond</a><ul><li><a href=#synccond-vs-syncmutex><code>sync.Cond</code> vs <code>sync.Mutex</code></a></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></aside></main></body></html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>函数 on Go 学习笔记</title><link>https://kingye.me/study-go/docs/basic/ref/keyword/func/</link><description>Recent content in 函数 on Go 学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/study-go/docs/basic/ref/keyword/func/index.xml" rel="self" type="application/rss+xml"/><item><title>init</title><link>https://kingye.me/study-go/docs/basic/ref/keyword/func/init/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/ref/keyword/func/init/</guid><description>&lt;h1 id="init-函数">
 init 函数
 &lt;a class="anchor" href="#init-%e5%87%bd%e6%95%b0">#&lt;/a>
&lt;/h1>
&lt;hr>
&lt;h2 id="作用">
 作用
 &lt;a class="anchor" href="#%e4%bd%9c%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>初始化不能采用&lt;strong>初始化表达式&lt;/strong>初始化的变量&lt;/li>
&lt;li>程序运行前的注册&lt;/li>
&lt;li>实现 sync.Once 功能&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="特点">
 特点
 &lt;a class="anchor" href="#%e7%89%b9%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>init 函数先于 main 函数自动执行&lt;/li>
&lt;li>init 不能被其他函数调用&lt;/li>
&lt;li>init 函数没有输入参数、返回值&lt;/li>
&lt;li>每个包可以有多个 init 函数
&lt;ul>
&lt;li>&lt;strong>包的每个源文件也可以有多个 init 函数&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>同一个包的 init 执行顺序，golang 没有明确定义，编程时要注意程序不要依赖这个执行顺序&lt;/li>
&lt;li>不同包的 init 函数按照包导入的依赖关系决定执行顺序&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="问答">
 问答
 &lt;a class="anchor" href="#%e9%97%ae%e7%ad%94">#&lt;/a>
&lt;/h2>
&lt;h3 id="只想调用该包的-init-函数不使用包导出的变量或者方法">
 只想调用该包的 init 函数，不使用包导出的变量或者方法
 &lt;a class="anchor" href="#%e5%8f%aa%e6%83%b3%e8%b0%83%e7%94%a8%e8%af%a5%e5%8c%85%e7%9a%84-init-%e5%87%bd%e6%95%b0%e4%b8%8d%e4%bd%bf%e7%94%a8%e5%8c%85%e5%af%bc%e5%87%ba%e7%9a%84%e5%8f%98%e9%87%8f%e6%88%96%e8%80%85%e6%96%b9%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#e6db74">&amp;#34;net/http/pprof&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行上述导入后，init 函数会启动一个异步协程采集该进程实例的资源占用情况，并以 http 服务接口方式提供给用户查询。&lt;/p>
&lt;hr>
&lt;h2 id="参考">
 参考
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83">#&lt;/a>
&lt;/h2></description></item><item><title>Receiver</title><link>https://kingye.me/study-go/docs/basic/ref/keyword/func/receiver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/basic/ref/keyword/func/receiver/</guid><description>&lt;h1 id="receiver">
 Receiver
 &lt;a class="anchor" href="#receiver">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>value method 可以被 value 和 pointer 对象调用
&lt;ul>
&lt;li>结构体类型实现的&lt;strong>接口&lt;/strong>，该结构体的&lt;strong>指针类型&lt;/strong>也算实现了该接口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>而 pointer method 只能被 pointer 对象调用
&lt;ul>
&lt;li>pointer method 会修改对象的值，而 value method 不会，所以如果在一个 value 对象上调用 pointer method，编译器会对原来的值做一份拷贝，并在拷贝后的值上执行函数，那么如果函数有修改原 receiver 的值，则修改的行为都发生在拷贝的值上，而不会影响原值，这个错误很隐蔽不容易被调试发现，因此 go 决定放弃这个错误发生的可能性，直接不支持 pointer method 被 value 对象调用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="使用规则">
 使用规则
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e8%a7%84%e5%88%99">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>必须使用指针
&lt;ul>
&lt;li>&lt;code>struct&lt;/code>，且包含 &lt;code>sync.Mutex&lt;/code> 类型字段&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>建议使用指针
&lt;ul>
&lt;li>比较&lt;strong>大&lt;/strong>的 struct/array
&lt;ul>
&lt;li>struct 或者 array 中的&lt;strong>元素个数超过 3 个&lt;/strong>，则认为比较大，反之，则认为比较小&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>struct、array 或 slice，其中指针元素所指的内容可能在方法内被&lt;strong>修改&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>建议使用 value 类型
&lt;ul>
&lt;li>比较&lt;strong>小&lt;/strong>的 struct/array&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>必须使用 value 类型（&lt;em>编程规范&lt;/em>）
&lt;ul>
&lt;li>map、函数或者 &lt;code>chan&lt;/code> 类型&lt;/li>
&lt;li>slice，并且方法不会进行 &lt;code>reslice&lt;/code> 或者重新分配 slice&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="value-vs-pointer">
 value vs pointer
 &lt;a class="anchor" href="#value-vs-pointer">#&lt;/a>
&lt;/h2>
&lt;p>参考：&lt;/p></description></item></channel></rss>
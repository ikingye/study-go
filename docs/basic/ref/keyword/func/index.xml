<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>函数 on Go 学习笔记</title>
    <link>https://kingye.me/study-go/docs/basic/ref/keyword/func/</link>
    <description>Recent content in 函数 on Go 学习笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://kingye.me/study-go/docs/basic/ref/keyword/func/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>init</title>
      <link>https://kingye.me/study-go/docs/basic/ref/keyword/func/init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-go/docs/basic/ref/keyword/func/init/</guid>
      <description>&lt;h1 id=&#34;init-函数&#34;&gt;&#xA;  init 函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#init-%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;作用&#34;&gt;&#xA;  作用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%9c%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化不能采用&lt;strong&gt;初始化表达式&lt;/strong&gt;初始化的变量&lt;/li&gt;&#xA;&lt;li&gt;程序运行前的注册&lt;/li&gt;&#xA;&lt;li&gt;实现 sync.Once 功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;init 函数先于 main 函数自动执行&lt;/li&gt;&#xA;&lt;li&gt;init 不能被其他函数调用&lt;/li&gt;&#xA;&lt;li&gt;init 函数没有输入参数、返回值&lt;/li&gt;&#xA;&lt;li&gt;每个包可以有多个 init 函数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;包的每个源文件也可以有多个 init 函数&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同一个包的 init 执行顺序，golang 没有明确定义，编程时要注意程序不要依赖这个执行顺序&lt;/li&gt;&#xA;&lt;li&gt;不同包的 init 函数按照包导入的依赖关系决定执行顺序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;问答&#34;&gt;&#xA;  问答&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e7%ad%94&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;只想调用该包的-init-函数不使用包导出的变量或者方法&#34;&gt;&#xA;  只想调用该包的 init 函数，不使用包导出的变量或者方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%aa%e6%83%b3%e8%b0%83%e7%94%a8%e8%af%a5%e5%8c%85%e7%9a%84-init-%e5%87%bd%e6%95%b0%e4%b8%8d%e4%bd%bf%e7%94%a8%e5%8c%85%e5%af%bc%e5%87%ba%e7%9a%84%e5%8f%98%e9%87%8f%e6%88%96%e8%80%85%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;net/http/pprof&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行上述导入后，init 函数会启动一个异步协程采集该进程实例的资源占用情况，并以 http 服务接口方式提供给用户查询。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Receiver</title>
      <link>https://kingye.me/study-go/docs/basic/ref/keyword/func/receiver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-go/docs/basic/ref/keyword/func/receiver/</guid>
      <description>&lt;h1 id=&#34;receiver&#34;&gt;&#xA;  Receiver&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#receiver&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;value method 可以被 value 和 pointer 对象调用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;结构体类型实现的&lt;strong&gt;接口&lt;/strong&gt;，该结构体的&lt;strong&gt;指针类型&lt;/strong&gt;也算实现了该接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;而 pointer method 只能被 pointer 对象调用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pointer method 会修改对象的值，而 value method 不会，所以如果在一个 value 对象上调用 pointer method，编译器会对原来的值做一份拷贝，并在拷贝后的值上执行函数，那么如果函数有修改原 receiver 的值，则修改的行为都发生在拷贝的值上，而不会影响原值，这个错误很隐蔽不容易被调试发现，因此 go 决定放弃这个错误发生的可能性，直接不支持 pointer method 被 value 对象调用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;使用规则&#34;&gt;&#xA;  使用规则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e8%a7%84%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必须使用指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;struct&lt;/code&gt;，且包含 &lt;code&gt;sync.Mutex&lt;/code&gt; 类型字段&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;建议使用指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;比较&lt;strong&gt;大&lt;/strong&gt;的 struct/array&#xA;&lt;ul&gt;&#xA;&lt;li&gt;struct 或者 array 中的&lt;strong&gt;元素个数超过 3 个&lt;/strong&gt;，则认为比较大，反之，则认为比较小&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;struct、array 或 slice，其中指针元素所指的内容可能在方法内被&lt;strong&gt;修改&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;建议使用 value 类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;比较&lt;strong&gt;小&lt;/strong&gt;的 struct/array&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;必须使用 value 类型（&lt;em&gt;编程规范&lt;/em&gt;）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;map、函数或者 &lt;code&gt;chan&lt;/code&gt; 类型&lt;/li&gt;&#xA;&lt;li&gt;slice，并且方法不会进行 &lt;code&gt;reslice&lt;/code&gt; 或者重新分配 slice&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;value-vs-pointer&#34;&gt;&#xA;  value vs pointer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#value-vs-pointer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;参考：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

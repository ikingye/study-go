<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>3.3 运行时 on Go 学习笔记</title>
    <link>https://kingye.me/study-go/docs/design/runtime/</link>
    <description>Recent content in 3.3 运行时 on Go 学习笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://kingye.me/study-go/docs/design/runtime/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 初始化</title>
      <link>https://kingye.me/study-go/docs/design/runtime/init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-go/docs/design/runtime/init/</guid>
      <description>&lt;h1 id=&#34;go-初始化&#34;&gt;&#xA;  Go 初始化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;golang 程序初始化先于 main 函数执行，由 runtime 进行初始化，初始化顺序如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime 需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见 golang 变量的初始化）；&lt;/li&gt;&#xA;&lt;li&gt;初始化包作用域的变量（该作用域的变量的初始化也并非按照 “从上到下、从左到右” 的顺序，runtime 解析变量依赖关系，没有依赖的变量最先初始化，参见 golang 变量的初始化）；&lt;/li&gt;&#xA;&lt;li&gt;执行包的 init 函数；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;变量初始化 -&amp;gt;init ()-&amp;gt;main ()&lt;/li&gt;&#xA;&lt;li&gt;由于 pack 包的初始化依赖 test_util，因此运行时先初始化 test_util 再初始化 pack 包；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同一个包不同源文件的 init 函数执行顺序，golang spec 没做说明&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一般是源文件名称的字典序，但不能依赖这个假定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在每一个初始化周期，运行时（runtime）会挑选一个没有任何依赖的变量初始化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;该过程一直持续到所有的变量均被初始化或者出现依赖嵌套的情形&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同一个 package 下多个文件的变量初始化依赖也遵循相同的规则&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;变量初始化&#34;&gt;&#xA;  变量初始化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;不同作用域类型的变量初始化顺序不同&lt;/p&gt;&#xA;&lt;h3 id=&#34;函数作用域内的局部变量&#34;&gt;&#xA;  函数作用域内的局部变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%86%85%e7%9a%84%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;初始化顺序：从左到右、从上到下&lt;/p&gt;&#xA;&lt;h3 id=&#34;package-级别的变量&#34;&gt;&#xA;  package 级别的变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#package-%e7%ba%a7%e5%88%ab%e7%9a%84%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;初始化顺序与&lt;code&gt;初始化依赖&lt;/code&gt;有关&lt;/p&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>Go 调度</title>
      <link>https://kingye.me/study-go/docs/design/runtime/scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-go/docs/design/runtime/scheduling/</guid>
      <description>&lt;h1 id=&#34;go-调度&#34;&gt;&#xA;  Go 调度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-%e8%b0%83%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;go-调度器的发展&#34;&gt;&#xA;  Go 调度器的发展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e5%8f%91%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单线程调度器・&lt;a href=&#34;https://github.com/golang/go/blob/96824000ed89d13665f6f24ddc10b3bf812e7f47/src/runtime/proc.c&#34;&gt;0.x&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只包含 40 多行代码；&lt;/li&gt;&#xA;&lt;li&gt;程序中只能存在一个活跃线程，由 G-M 模型组成；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;多线程调度器・&lt;a href=&#34;https://github.com/golang/go/blob/go1.0.1/src/pkg/runtime/proc.c&#34;&gt;1.0&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;允许运行多线程的程序；&lt;/li&gt;&#xA;&lt;li&gt;全局锁导致竞争严重；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;任务窃取调度器・&lt;a href=&#34;https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c&#34;&gt;1.1&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引入了处理器 P，构成了目前的  G-M-P  模型；&lt;/li&gt;&#xA;&lt;li&gt;在处理器 P 的基础上实现了基于工作窃取的调度器；&lt;/li&gt;&#xA;&lt;li&gt;在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；&lt;/li&gt;&#xA;&lt;li&gt;时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;抢占式调度器・&lt;a href=&#34;https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c&#34;&gt;1.2&lt;/a&gt; ~ 至今&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于协作的抢占式调度器 - 1.2 ~ 1.13&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；&lt;/li&gt;&#xA;&lt;li&gt;Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;基于信号的抢占式调度器 - 1.14 ~ 至今&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现基于信号的真抢占式调度；&lt;/li&gt;&#xA;&lt;li&gt;垃圾回收在扫描栈时会触发抢占调度；&lt;/li&gt;&#xA;&lt;li&gt;抢占的时间点不够多，还不能覆盖全部的边缘情况；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;非均匀存储访问调度器・提案&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对运行时的各种资源进行分区；&lt;/li&gt;&#xA;&lt;li&gt;实现非常复杂，到今天还没有提上日程；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;除了多线程、任务窃取和抢占式调度器之外，Go 语言社区目前还有一个非均匀存储访问（Non-uniform memory access，NUMA）调度器的提案，Go 语言在未来也有实现该提案的可能。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/&#34;&gt;Go 语言调度器与 Goroutine 实现原理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;The Go scheduler (Go 1.1)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;scheduling-in-gohttpswwwardanlabscomblog201808scheduling-in-go-part1html&#34;&gt;&#xA;  &lt;a href=&#34;https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html&#34;&gt;Scheduling In Go&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#scheduling-in-gohttpswwwardanlabscomblog201808scheduling-in-go-part1html&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html&#34;&gt;Scheduling In Go : Part I - OS Scheduler&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html&#34;&gt;Scheduling In Go : Part II - Go Scheduler&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html&#34;&gt;Scheduling In Go : Part III - Concurrency&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;garbage-collection-in-gohttpswwwardanlabscomblog201812garbage-collection-in-go-part1-semanticshtml&#34;&gt;&#xA;  &lt;a href=&#34;https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html&#34;&gt;Garbage Collection In Go&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#garbage-collection-in-gohttpswwwardanlabscomblog201812garbage-collection-in-go-part1-semanticshtml&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html&#34;&gt;Garbage Collection In Go : Part I - Semantics&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html&#34;&gt;Garbage Collection In Go : Part II - GC Traces&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html&#34;&gt;Garbage Collection In Go : Part III - GC Pacing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>GC</title>
      <link>https://kingye.me/study-go/docs/design/runtime/gc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-go/docs/design/runtime/gc/</guid>
      <description>&lt;h1 id=&#34;go-gc&#34;&gt;&#xA;  Go GC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-gc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;Garbage Collection&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>并发</title>
      <link>https://kingye.me/study-go/docs/design/runtime/concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-go/docs/design/runtime/concurrent/</guid>
      <description>&lt;h1 id=&#34;go-并发&#34;&gt;&#xA;  Go 并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;mutex&#34;&gt;&#xA;  Mutex&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mutex&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Mutex&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 状态&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;sema&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 信号量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;state (32 位)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;waitersCount (29 位): 当前互斥锁上等待的 Goroutine 个数&lt;/li&gt;&#xA;&lt;li&gt;mutexStarving (1 位): 当前的互斥锁进入&lt;strong&gt;饥饿状态&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Goroutine 超过 1 ms 没有获取到锁，就会转为饥饿模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;mutexWoken (1 位): 从正常模式被从唤醒&lt;/li&gt;&#xA;&lt;li&gt;mutexLocked (1 位): 互斥锁的锁定状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>

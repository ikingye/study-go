<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>3.3 运行时 on Go 学习笔记</title><link>https://kingye.me/study-go/docs/design/runtime/</link><description>Recent content in 3.3 运行时 on Go 学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/study-go/docs/design/runtime/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 初始化</title><link>https://kingye.me/study-go/docs/design/runtime/init/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/design/runtime/init/</guid><description>&lt;h1 id="go-初始化">
 Go 初始化
 &lt;a class="anchor" href="#go-%e5%88%9d%e5%a7%8b%e5%8c%96">#&lt;/a>
&lt;/h1>
&lt;p>golang 程序初始化先于 main 函数执行，由 runtime 进行初始化，初始化顺序如下：&lt;/p>
&lt;ul>
&lt;li>初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime 需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见 golang 变量的初始化）；&lt;/li>
&lt;li>初始化包作用域的变量（该作用域的变量的初始化也并非按照 “从上到下、从左到右” 的顺序，runtime 解析变量依赖关系，没有依赖的变量最先初始化，参见 golang 变量的初始化）；&lt;/li>
&lt;li>执行包的 init 函数；&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>变量初始化 -&amp;gt;init ()-&amp;gt;main ()&lt;/li>
&lt;li>由于 pack 包的初始化依赖 test_util，因此运行时先初始化 test_util 再初始化 pack 包；&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>同一个包不同源文件的 init 函数执行顺序，golang spec 没做说明
&lt;ul>
&lt;li>一般是源文件名称的字典序，但不能依赖这个假定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>在每一个初始化周期，运行时（runtime）会挑选一个没有任何依赖的变量初始化
&lt;ul>
&lt;li>该过程一直持续到所有的变量均被初始化或者出现依赖嵌套的情形&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>同一个 package 下多个文件的变量初始化依赖也遵循相同的规则&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="变量初始化">
 变量初始化
 &lt;a class="anchor" href="#%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;p>不同作用域类型的变量初始化顺序不同&lt;/p>
&lt;h3 id="函数作用域内的局部变量">
 函数作用域内的局部变量
 &lt;a class="anchor" href="#%e5%87%bd%e6%95%b0%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%86%85%e7%9a%84%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f">#&lt;/a>
&lt;/h3>
&lt;p>初始化顺序：从左到右、从上到下&lt;/p>
&lt;h3 id="package-级别的变量">
 package 级别的变量
 &lt;a class="anchor" href="#package-%e7%ba%a7%e5%88%ab%e7%9a%84%e5%8f%98%e9%87%8f">#&lt;/a>
&lt;/h3>
&lt;p>初始化顺序与&lt;code>初始化依赖&lt;/code>有关&lt;/p>
&lt;hr></description></item><item><title>Go 调度</title><link>https://kingye.me/study-go/docs/design/runtime/scheduling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/design/runtime/scheduling/</guid><description>&lt;h1 id="go-调度">
 Go 调度
 &lt;a class="anchor" href="#go-%e8%b0%83%e5%ba%a6">#&lt;/a>
&lt;/h1>
&lt;h2 id="go-调度器的发展">
 Go 调度器的发展
 &lt;a class="anchor" href="#go-%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e5%8f%91%e5%b1%95">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>单线程调度器・&lt;a href="https://github.com/golang/go/blob/96824000ed89d13665f6f24ddc10b3bf812e7f47/src/runtime/proc.c">0.x&lt;/a>
&lt;ul>
&lt;li>只包含 40 多行代码；&lt;/li>
&lt;li>程序中只能存在一个活跃线程，由 G-M 模型组成；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多线程调度器・&lt;a href="https://github.com/golang/go/blob/go1.0.1/src/pkg/runtime/proc.c">1.0&lt;/a>
&lt;ul>
&lt;li>允许运行多线程的程序；&lt;/li>
&lt;li>全局锁导致竞争严重；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>任务窃取调度器・&lt;a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c">1.1&lt;/a>
&lt;ul>
&lt;li>引入了处理器 P，构成了目前的  G-M-P  模型；&lt;/li>
&lt;li>在处理器 P 的基础上实现了基于工作窃取的调度器；&lt;/li>
&lt;li>在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；&lt;/li>
&lt;li>时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抢占式调度器・&lt;a href="https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c">1.2&lt;/a> ~ 至今
&lt;ul>
&lt;li>基于协作的抢占式调度器 - 1.2 ~ 1.13
&lt;ul>
&lt;li>通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；&lt;/li>
&lt;li>Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于信号的抢占式调度器 - 1.14 ~ 至今
&lt;ul>
&lt;li>实现基于信号的真抢占式调度；&lt;/li>
&lt;li>垃圾回收在扫描栈时会触发抢占调度；&lt;/li>
&lt;li>抢占的时间点不够多，还不能覆盖全部的边缘情况；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>非均匀存储访问调度器・提案
&lt;ul>
&lt;li>对运行时的各种资源进行分区；&lt;/li>
&lt;li>实现非常复杂，到今天还没有提上日程；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>除了多线程、任务窃取和抢占式调度器之外，Go 语言社区目前还有一个非均匀存储访问（Non-uniform memory access，NUMA）调度器的提案，Go 语言在未来也有实现该提案的可能。&lt;/p>
&lt;hr>
&lt;h2 id="参考">
 参考
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">Go 语言调度器与 Goroutine 实现原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://morsmachine.dk/go-scheduler">The Go scheduler (Go 1.1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="scheduling-in-gohttpswwwardanlabscomblog201808scheduling-in-go-part1html">
 &lt;a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">Scheduling In Go&lt;/a>
 &lt;a class="anchor" href="#scheduling-in-gohttpswwwardanlabscomblog201808scheduling-in-go-part1html">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">Scheduling In Go : Part I - OS Scheduler&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part II - Go Scheduler&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">Scheduling In Go : Part III - Concurrency&lt;/a>&lt;/li>
&lt;/ol>
&lt;h3 id="garbage-collection-in-gohttpswwwardanlabscomblog201812garbage-collection-in-go-part1-semanticshtml">
 &lt;a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">Garbage Collection In Go&lt;/a>
 &lt;a class="anchor" href="#garbage-collection-in-gohttpswwwardanlabscomblog201812garbage-collection-in-go-part1-semanticshtml">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">Garbage Collection In Go : Part I - Semantics&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html">Garbage Collection In Go : Part II - GC Traces&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html">Garbage Collection In Go : Part III - GC Pacing&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>GC</title><link>https://kingye.me/study-go/docs/design/runtime/gc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/design/runtime/gc/</guid><description>&lt;h1 id="go-gc">
 Go GC
 &lt;a class="anchor" href="#go-gc">#&lt;/a>
&lt;/h1>
&lt;p>&lt;code>Garbage Collection&lt;/code>&lt;/p></description></item><item><title>并发</title><link>https://kingye.me/study-go/docs/design/runtime/concurrent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-go/docs/design/runtime/concurrent/</guid><description>&lt;h1 id="go-并发">
 Go 并发
 &lt;a class="anchor" href="#go-%e5%b9%b6%e5%8f%91">#&lt;/a>
&lt;/h1>
&lt;h2 id="mutex">
 Mutex
 &lt;a class="anchor" href="#mutex">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Mutex&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> &lt;span style="color:#75715e">// 状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">sema&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span> &lt;span style="color:#75715e">// 信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>state (32 位)
&lt;ul>
&lt;li>waitersCount (29 位): 当前互斥锁上等待的 Goroutine 个数&lt;/li>
&lt;li>mutexStarving (1 位): 当前的互斥锁进入&lt;strong>饥饿状态&lt;/strong>
&lt;ul>
&lt;li>Goroutine 超过 1 ms 没有获取到锁，就会转为饥饿模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>mutexWoken (1 位): 从正常模式被从唤醒&lt;/li>
&lt;li>mutexLocked (1 位): 互斥锁的锁定状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>
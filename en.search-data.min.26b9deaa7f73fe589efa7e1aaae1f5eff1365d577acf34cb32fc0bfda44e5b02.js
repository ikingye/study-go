'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-go/docs/basic/grammar/quick/','title':"Go 快速上手",'content':"Go 快速上手 Go 环境 GOROOT GOROOT: 指定安装 GO 的根目录\nGo 1.0 之后，go tool 利用 GOROOT 查找 Go 编译器（保存在 $GOROOT/pkg/tool/$GOOS_$GOARCH） 和标准库（在 $GOROOT/pkg/$GOOS_$GOARCH）\n可以将 GOROOT 理解为 Java 的 JAVA_HOME。\n我们不应该设置 GOROOT，是因为 Go 工具链已经内置了正确的值。 除非：\n 如果你是 Linux、FreeBSD 或者 OS X 用户，下载了 zip 和 tarball 的二进制包安装环境。这些二进制的默认环境位于 /usr/local/go，建议你将 Go 安装到这个位置。如果选择不这么做，就必须设置到你指定的目录下。 如果你是 Windows 用户，使用 zip 二进制包安装，默认的 GOROOT 在 C:\\Go 目录下。如果你将 Go 安装在其他位置，请设置 GOROOT 到指定的目录。  GOPATH GOPATH: go 包的位置\nGOOS vs GOARCH 随着 go tool 的引入，Go 1.0 之前，GOOS 和 GOARCH 已经变成可选了，因为构建脚本已经能自动检测出系统类别和 CPU 架构。\n在 Go 1.0 的发布后，引入了 cmd/dist 引导构建工具，GOOS 和 GOARCH 真正意义上是可选项了，仅仅在交叉编译时才会用到。\n"});index.add({'id':1,'href':'/study-go/docs/basic/lib/std/sort/','title':"sort",'content':"sort 自定义排序 实现 Len、Less 和 Swap 方法\n// 有时候，我们可能想根据自然顺序以外的方式来对集合进行排序。 // 例如，假设我们要按字符串的长度而不是按字母顺序对它们进行排序。 // 这儿有一个在 Go 中自定义排序的示例。  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) // 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。 // 我们在这里创建了一个 `byLength` 类型，它只是内建类型 `[]string` 的别名。 type byLength []string // 我们为该类型实现了 `sort.Interface` 接口的 `Len`、`Less` 和 `Swap` 方法， // 这样我们就可以使用 `sort` 包的通用 `Sort` 方法了， // `Len` 和 `Swap` 在各个类型中的实现都差不多， // `Less` 将控制实际的自定义排序逻辑。 // 在这个的例子中，我们想按字符串长度递增的顺序来排序， // 所以这里使用了 `len(s[i])` 和 `len(s[j])` 来实现 `Less`。 func (s byLength) Len() int { return len(s) } func (s byLength) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s byLength) Less(i, j int) bool { return len(s[i]) \u0026lt; len(s[j]) } // 一切准备就绪后，我们就可以通过将切片 `fruits` 强转为 `byLength` 类型的切片， // 然后对该切片使用 `sort.Sort` 来实现自定义排序。 func main() { fruits := []string{\u0026#34;peach\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;kiwi\u0026#34;} sort.Sort(byLength(fruits)) fmt.Println(fruits) } "});index.add({'id':2,'href':'/study-go/docs/basic/lib/std/','title':"标准库",'content':"Go 标准库 教程 polaris1119/The-Golang-Standard-Library-by-Example  Golang 标准库。对于程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案。\n以示例驱动的方式讲解 Golang 的标准库。\n"});index.add({'id':3,'href':'/study-go/docs/basic/practice/spec/baidu/','title':"百度",'content':"百度 Golang 编码规范 V1.2 "});index.add({'id':4,'href':'/study-go/docs/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':5,'href':'/study-go/docs/basic/practice/spec/','title':"编程规范",'content':"Go 编程规范 代码组织 建议文件按以下顺序进行布局：\n General Documentation: 对整个模块和功能的完整描述注释，写在文件头部。 package: 当前 package 定义 imports: 包含的头文件 Constants: 常量 Typedefs: 类型定义 Globals: 全局变量定义 functions: 函数实现   语言规范 申明 slice 申明 slice 时，建议使用 var 方式申明，不建议使用大括号的方式\n// GOOD: var t []string // BAD: t := []string{} embedding  embedding 只用于 \u0026ldquo;is a\u0026rdquo; 的语义下，而不用于 \u0026ldquo;has a\u0026rdquo; 的语义下  语义上 embedding 是一种继承关系，而不是成员关系   一个定义内，多于一个的 embedding 尽量少用  一个定义内有多个 embedding，则很难判断某个成员变量或函数是从哪里继承得到的 一个定义内有多个 embedding，危害和在 python 中使用 from xxx import * 是类似的    type Automobile struct { // ... } type Engine struct { // .... } // GOOD: type Car struct { Automobile // Car is a Automobile  engine Engine // Car has a Engine } // BAD: type Car struct { Automobile // Car is a Automobile  Engine // Car has a Engine, but Car is NOT a Engine } 函数参数和返回值   必须\n 函数返回值小于等于 3 个，大于 3 个时必须通过 struct 进行包装    建议\n 函数参数不建议超过 3 个，大于 3 个时建议通过 struct 进行包装 函数返回值  逻辑判断型：返回值的意义代表 “真” 或 “假”，返回值类型定义为 bool 操作型：返回值的意义代表 “成功” 或 “失败”，返回值类型定义为 error 获取数据型：返回值的意义代表 “有数据” 或 “无数据 / 获取数据失败”，返回值类型定义为（data, error）      缩进  使用 tab 进行缩进。 跨行的缩进使用 gofmt 的缩进方式。 设置 tabstop=4  空格  圆括号、方括号、花括号内侧都不加空格 逗号、冒号（slice 中冒号除外）前不加空格，后边加一个空格 所有二元运算符前后各加一个空格（作为函数参数时除外）  var ( s = make([]int, 10) ) // GOOD： func foo() { m := map[string]string{\u0026#34;language\u0026#34;: \u0026#34;golang\u0026#34;} r := 1 + 2 func1(1+2) fmt.Println(m[\u0026#34;language\u0026#34;]) } // BAD： func foo() { m := map[string]string{ \u0026#34;language\u0026#34; : \u0026#34;golang\u0026#34; } r := 1+2 func1(1 + 2) fmt.Println(m[ \u0026#34;language\u0026#34; ]) }  命名 文件名 文件名都使用小写字母，如果需要，可以使用下划线分割\n文件名的后缀使用小写字母\n函数名 / 变量名 采用驼峰方式命名，禁止使用下划线命名\n首字母是否大写，根据是否需要外部访问来决定\n常量 尽量不要在程序中直接写数字，特殊字符串，全部用常量替代\n 编程实践 error string error string 尽量使用小写字母，并且结尾不带标点符号\nDon\u0026rsquo;t panic 除非出现不可恢复的程序错误，不要使用 panic，用多返回值和 error。\n关于 lock 的保护  如果临界区内的逻辑较复杂、无法完全避免 panic 的发生，则要求适用 defer 来调用 Unlock，即使在临界区过程中发生了 panic，也会在函数退出时调用 Unlock 释放锁  go 提供了 recover，可以对 panic 进行捕获，但如果 panic 发生在临界区内，则可能导致对锁的使用没有释放 这种情况下，即使 panic 不会导致整个程序的奔溃，也会由于” 锁不释放 “的问题而使临界区无法被后续的调用访问     上述操作如果造成临界区扩大后，需要建立单独的一个函数访问临界区。  func doDemo() { lock.Lock() // step1: 临界区内的操作  lock.Unlock() // step2: 临界区外的操作 } // 如果改造为 defer 的方式，变为如下代码，实际上扩大了临界区的范围（step2 的操作也被放置在临界区了） func doDemo() { lock.Lock() defer lock.Unlock() // step1: 临界区内的操作  // step2: 临界区外的操作 } // 需要使用单独的匿名函数，专门用于访问临界区 func doDemo() { func() { lock.Lock() defer lock.Unlock() // step1: 临界区内的操作操作  }() // step2: 临界区外的操作 } unsafe package  除非特殊原因，不建议使用 unsafe package  比如进行指针和数值 uintptr 之间转换就是一个特殊原因    "});index.add({'id':6,'href':'/study-go/docs/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':7,'href':'/study-go/docs/basic/lib/common/','title':"常用 package",'content':"Go 常用 package net imroc/req  Go 语言人性化 HTTP 请求库\n cmd spf13/cobra  A Commander for modern Go CLI interactions\nquick start typically a Cobra-based application will follow the following organizational structure:\n▾ appName/ ▾ cmd/ add.go your.go commands.go here.go main.go In a Cobra app, typically the main.go file is very bare. It serves one purpose: initializing Cobra.\npackage main import ( \u0026#34;{pathToYourApp}/cmd\u0026#34; ) func main() { cmd.Execute() } Ideally you place this in app/cmd/root.go:\nvar rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, Short: \u0026#34;Hugo is a very fast static site generator\u0026#34;, Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`, Run: func(cmd *cobra.Command, args []string) { // 在这里写应用逻辑  }, } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } }  web gorilla/mux  A powerful HTTP router and URL matcher for building Go web servers\ngithubnemo/CompileDaemon  Watches your .go files in a directory and invokes go build if a file changed.\nUsage:\n./CompileDaemon -directory=yourproject/\n其他 gomodule/redigo  Go client for Redis\ngo-redis/redis  Type-safe Redis client for Golang\nhttps://godoc.org/github.com/go-redis/redis\n"});index.add({'id':8,'href':'/study-go/docs/design/','title':"第二部分 设计",'content':""});index.add({'id':9,'href':'/study-go/docs/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':10,'href':'/study-go/docs/source/','title':"第三部分 源码实现",'content':"如无特殊说明，源码版本为 1.14.2  "});index.add({'id':11,'href':'/study-go/docs/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':12,'href':'/study-go/docs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':13,'href':'/study-go/docs/basic/grammar/defer/','title':"defer",'content':"defer 用于确保程序在执行完成后，会调用某个函数，一般是执行清理工作。\nDefer 的用途跟其他语言的 ensure 或 finally 类似。\n当 defer 释放锁遇到尾递归 var mut = sync.Mutex{} func tailRec(i int) int { mut.Lock() // 加锁  defer mut.Unlock() // defer 释放锁  if i == 10 { return i } i++ return tailRec(i) // return 尾递归 } 以上代码执行会发生死锁，原因是 return 语句后的命令先执行，赋值给匿名返回值后，再调用 defer， 因此尾递归中 tailRec 的加锁会在 defer 释放锁之前进行，形成死锁。\n根因是 golang 处理 defer 和 return 的顺序为， 计算 return 语句的返回值、赋值给匿名 / 有名返回值 -\u0026gt;defer-\u0026gt;RET 退出函数\n"});index.add({'id':14,'href':'/study-go/docs/basic/grammar/error/','title':"error",'content':"error 实现 Error() string 方法的类型，都是 error 类型\ntype error interface { Error() string } errors.New(\u0026#34;xxxx\u0026#34;) fmt.Errorf(format string, a ...interface{}) "});index.add({'id':15,'href':'/study-go/docs/design/runtime/init/','title':"Go 初始化",'content':"Go 初始化 golang 程序初始化先于 main 函数执行，由 runtime 进行初始化，初始化顺序如下：\n 初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime 需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见 golang 变量的初始化）； 初始化包作用域的变量（该作用域的变量的初始化也并非按照 “从上到下、从左到右” 的顺序，runtime 解析变量依赖关系，没有依赖的变量最先初始化，参见 golang 变量的初始化）； 执行包的 init 函数；   变量初始化 -\u0026gt;init ()-\u0026gt;main () 由于 pack 包的初始化依赖 test_util，因此运行时先初始化 test_util 再初始化 pack 包；   同一个包不同源文件的 init 函数执行顺序，golang spec 没做说明  一般是源文件名称的字典序，但不能依赖这个假定     在每一个初始化周期，运行时（runtime）会挑选一个没有任何依赖的变量初始化  该过程一直持续到所有的变量均被初始化或者出现依赖嵌套的情形   同一个 package 下多个文件的变量初始化依赖也遵循相同的规则   变量初始化 不同作用域类型的变量初始化顺序不同\n函数作用域内的局部变量 初始化顺序：从左到右、从上到下\npackage 级别的变量 初始化顺序与初始化依赖有关\n "});index.add({'id':16,'href':'/study-go/docs/basic/practice/command/','title':"Go 命令",'content':"Go 命令 go get 等于 go get -d 加 go install\ngo get -d 只下载不安装 -u 强制使用网络去更新包和它的依赖包 -f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用 -v 显示执行的命令 -t 同时也下载需要为运行测试所需要的包 -fix 在获取源码之后先运行 fix，然后再去做其他的事情 -insecure 允许使用不安全的 HTTP 方式进行下载操作 go get 后面不带参数时  go get 等同于 go install go get -d 等同于 go list  参考：\n What is the difference between go get and go install?   go install  第一步是生成结果文件（可执行文件或者 .a 包）， 第二步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。   go list "});index.add({'id':17,'href':'/study-go/docs/design/scheduling/','title':"Go 调度",'content':"Go 调度 参考 Scheduling In Go  Scheduling In Go : Part I - OS Scheduler Scheduling In Go : Part II - Go Scheduler Scheduling In Go : Part III - Concurrency  Garbage Collection In Go  Garbage Collection In Go : Part I - Semantics Garbage Collection In Go : Part II - GC Traces Garbage Collection In Go : Part III - GC Pacing  "});index.add({'id':18,'href':'/study-go/docs/basic/grammar/func/init/','title':"init",'content':"init 函数  作用  初始化不能采用初始化表达式初始化的变量 程序运行前的注册 实现 sync.Once 功能   特点  init 函数先于 main 函数自动执行 init 不能被其他函数调用 init 函数没有输入参数、返回值 每个包可以有多个 init 函数  包的每个源文件也可以有多个 init 函数   同一个包的 init 执行顺序，golang 没有明确定义，编程时要注意程序不要依赖这个执行顺序 不同包的 init 函数按照包导入的依赖关系决定执行顺序   问答 只想调用该包的 init 函数，不使用包导出的变量或者方法 import _ \u0026#34;net/http/pprof\u0026#34; 执行上述导入后，init 函数会启动一个异步协程采集该进程实例的资源占用情况，并以 http 服务接口方式提供给用户查询。\n 参考 "});index.add({'id':19,'href':'/study-go/docs/design/interface/','title':"interface",'content':"interface Go Data Structures: Interfaces\n读完这篇 go 作者的 blog，interface 就没什么秘密可言了。每个 interface 至少包含两个字段，type 和 data，不论什么形式，然后是 itable 什么时候生成，如何调用。\n结合 Comparison operators，记住 interface 的 compare 规则。\n"});index.add({'id':20,'href':'/study-go/docs/basic/grammar/func/receiver/','title':"Receiver",'content':"Receiver 结构体类型实现的接口，该结构体的指针类型也算实现了\n使用规则  必须使用指针  struct，且包含 sync.Mutex 类型字段   建议使用指针  比较大的 struct/array  struct 或者 array 中的元素个数超过 3 个，则认为比较大，反之，则认为比较小   struct、array 或 slice，其中指针元素所指的内容可能在方法内被修改   建议使用 value 类型  比较小的 struct/array   必须使用 value 类型（编程规范）  map、函数或者 chan 类型 slice，并且方法不会进行 reslice 或者重新分配 slice    method expression package main import ( \u0026#34;fmt\u0026#34; ) type Ball struct { Name string } func (b *Ball) Ping() { fmt.Println(\u0026#34;ping\u0026#34;) } func (b Ball) Pong() { fmt.Println(\u0026#34;pong\u0026#34;) } func main() { v := Ball{} Ball.Ping(\u0026amp;v) Ball.Pong(v) } "});index.add({'id':21,'href':'/study-go/docs/design/pros-and-cons/','title':"优劣",'content':"Go 语言优劣 Go 的优点 部署简单  直接编译成机器码 不依赖其他库 直接运行即可部署  静态类型语言 编译时可检测出隐藏的大多数问题\n语言层面实现并发（goroutine） 强大的标准库  runtime 系统调度机制 高效的 GC（垃圾回收） 丰富的标准库  简单易学  25 个关键字 内嵌 C 语法支持（CGO） 面向对象 跨平台  背靠大厂（Google） 性能好  Go 的缺点 无泛化类型 传言 Go 2.0 会加上\n无 Exception，都用 Error 有争议\n包管理大部分在 Github 参考：\n 2020 年以后是 Go 的天下吗？  "});index.add({'id':22,'href':'/study-go/docs/basic/grammar/keyword/','title':"关键字",'content':"Go 语言关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var for 与 range select defer panic 与 recover make 与 new "});index.add({'id':23,'href':'/study-go/docs/appendix/tutorial/','title':"教程",'content':"Go 教程 基础 astaxie/build-web-application-with-golang  A golang ebook intro how to build a web with golang\nmmcgrana/gobyexample  Go by Example\n中文翻译：通过例子学 Golang：https://gobyexample-cn.github.io/\ngeektutu/7days-golang  7 天用 Go 动手写 / 从零实现系列\ngolang101/golang101  Go 语言 101 : 一本侧重于 Go 语言语法和语义的编程解释和指导书 https://gfw.go101.org\npolaris1119/The-Golang-Standard-Library-by-Example  Golang 标准库。对于程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案。\n以示例驱动的方式讲解 Golang 的标准库。\ninancgumus/learngo  1000+ Hand-Crafted Go Examples, Exercises, and Quizzes\nardanlabs/gotraining  Go Training Class Material : http://www.ArdanLabs.com\n进阶 Go 语言设计与实现 by Draveness 高阶 "});index.add({'id':24,'href':'/study-go/docs/basic/grammar/format/','title':"格式化输出",'content':"格式化输出 // Go 提供了一些用于格式化常规值的打印“动词”。 // 例如，这样打印 `point` 结构体的实例。 p := point{1, 2} fmt.Printf(\u0026#34;%v\\n\u0026#34;, p) // 如果值是一个结构体，`%+v` 的格式化输出内容将包括结构体的字段名。 fmt.Printf(\u0026#34;%+v\\n\u0026#34;, p) // `%#v` 根据 Go 语法输出值，即会产生该值的源码片段。 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, p) // 需要打印值的类型，使用 `%T`。 fmt.Printf(\u0026#34;%T\\n\u0026#34;, p) // 格式化布尔值很简单。 fmt.Printf(\u0026#34;%t\\n\u0026#34;, true) // 格式化整型数有多种方式，使用 `%d` 进行标准的十进制格式化。 fmt.Printf(\u0026#34;%d\\n\u0026#34;, 123) // 这个输出二进制表示形式。 fmt.Printf(\u0026#34;%b\\n\u0026#34;, 14) // 输出给定整数的对应字符。 fmt.Printf(\u0026#34;%c\\n\u0026#34;, 33) // `%x` 提供了十六进制编码。 fmt.Printf(\u0026#34;%x\\n\u0026#34;, 456) // 同样的，也为浮点型提供了多种格式化选项。 // 使用 `%f` 进行最基本的十进制格式化。 fmt.Printf(\u0026#34;%f\\n\u0026#34;, 78.9) // `%e` 和 `%E` 将浮点型格式化为（稍微有一点不同的）科学记数法表示形式。 fmt.Printf(\u0026#34;%e\\n\u0026#34;, 123400000.0) fmt.Printf(\u0026#34;%E\\n\u0026#34;, 123400000.0) // 使用 `%s` 进行基本的字符串输出。 fmt.Printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;\\\u0026#34;string\\\u0026#34;\u0026#34;) // 像 Go 源代码中那样带有双引号的输出，使用 `%q`。 fmt.Printf(\u0026#34;%q\\n\u0026#34;, \u0026#34;\\\u0026#34;string\\\u0026#34;\u0026#34;) // 和上面的整型数一样，`%x` 输出使用 base-16 编码的字符串， // 每个字节使用 2 个字符表示。 fmt.Printf(\u0026#34;%x\\n\u0026#34;, \u0026#34;hex this\u0026#34;) // 要输出一个指针的值，使用 `%p`。 fmt.Printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;p) // 格式化数字时，您经常会希望控制输出结果的宽度和精度。 // 要指定整数的宽度，请在动词 \u0026#34;%\u0026#34; 之后使用数字。 // 默认情况下，结果会右对齐并用空格填充。 fmt.Printf(\u0026#34;|%6d|%6d|\\n\u0026#34;, 12, 345) // 你也可以指定浮点型的输出宽度，同时也可以通过 `宽度.精度` 的语法来指定输出的精度。 fmt.Printf(\u0026#34;|%6.2f|%6.2f|\\n\u0026#34;, 1.2, 3.45) // 要左对齐，使用 `-` 标志。 fmt.Printf(\u0026#34;|%-6.2f|%-6.2f|\\n\u0026#34;, 1.2, 3.45) // 你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。 // 这是基本的宽度右对齐方法。 fmt.Printf(\u0026#34;|%6s|%6s|\\n\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;b\u0026#34;) // 要左对齐，和数字一样，使用 `-` 标志。 fmt.Printf(\u0026#34;|%-6s|%-6s|\\n\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;b\u0026#34;) // 到目前为止，我们已经看过 `Printf` 了， // 它通过 `os.Stdout` 输出格式化的字符串。 // `Sprintf` 则格式化并返回一个字符串而没有任何输出。 s := fmt.Sprintf(\u0026#34;a %s\u0026#34;, \u0026#34;string\u0026#34;) fmt.Println(s) // 你可以使用 `Fprintf` 来格式化并输出到 `io.Writers` 而不是 `os.Stdout`。 fmt.Fprintf(os.Stderr, \u0026#34;an %s\\n\u0026#34;, \u0026#34;error\u0026#34;) "});index.add({'id':25,'href':'/study-go/docs/design/type/','title':"类型系统",'content':"Go 类型系统 Underlying Type  每一个类型都有自己的 Underlying Type  如果 T 是 Pre-declared type 或者 Type Literal，它们对应的 Underlying Type 就是自身 T  比如 type T int 的 Underlying Type 是 int  int 是 Pre-declared   type T map[int]string 的 Underlying Type 是 map[int]string  map[int]string 是 Type Literal     否则 T 的 Underlying Type 是 T 定义时引用的类型的 Underlying Type    Underlying Type 相同 如果两个 type 的 Underlying Type 相同，则它们可以有以下特性：\n  如果两个 type 都是 named type ，彼此之间不能相互赋值\ntype NewString string var my string =\u0026#34;a\u0026#34; // cannot use my (type string) as type NewString in assignment // 虽然它们的 Underlying Type 都是 string，但 string 类型的 my 不能赋值给 NewString 类型的 you var you NewString = my   如果两个 type 其中一个是 Unnamed Type，彼此之间可以相互赋值\npackage main type Ptr *int //named type type Map map[int]string type MapMap Map func main() { var p *int var mm Map var mmm MapMap // m1 m2 是 Unnamed Type  var m1 map[int]string = mm var m2 map[int]string = mmm var ptr Ptr = p print(ptr) print(m1) print(m2) }   原因： 如果为一个类型起了名字，说明你想要做区分，所以两个 named types 即使 Underlying Type 相同也是不能相互赋值的。\n参考：\n 理解 Go 类型系统 Google Group Topic  "});index.add({'id':26,'href':'/study-go/docs/basic/grammar/','title':"语法",'content':"Go 语法 变量 var a string = \u0026#34;short\u0026#34; // Go 会自动推断已经有初始值的变量的类型。 var b = true // 声明后却没有给出对应的初始值时，变量将会初始化为零值 。 // 例如，`int` 的零值是 `0`。 var c int // `:=` 语法是声明并初始化变量的简写， d := \u0026#34;short\u0026#34;  常量 const 语句可以出现在任何 var 语句可以出现的地方\n一个数字可以根据上下文的需要（比如变量赋值、函数调用）自动确定类型。\n// 这里的 `math.Sin` 函数需要一个 `float64` 的参数，`n` 会自动确定类型。 const n = 500000000 fmt.Println(math.Sin(n))  for 循环 for 是 Go 中唯一的循环结构。\n// 最基础的方式，单个循环条件。 i := 1 for i \u0026lt;= 3 { fmt.Println(i) i = i + 1 } // 经典的初始/条件/后续 `for` 循环。 for j := 7; j \u0026lt;= 9; j++ { fmt.Println(j) } // 不带条件的 `for` 循环将一直重复执行， // 直到在循环体内使用了 `break` 或者 `return` 跳出循环。 for { fmt.Println(\u0026#34;loop\u0026#34;) break } // 你也可以使用 `continue` 直接进入下一次循环。 for n := 0; n \u0026lt;= 5; n++ { if n%2 == 0 { continue } fmt.Println(n) }  switch case 表达式可以不使用常量\n不带表达式的 switch 是实现 if/else 逻辑的另一种方式。\nt := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;It\u0026#39;s before noon\u0026#34;) default: fmt.Println(\u0026#34;It\u0026#39;s after noon\u0026#34;) } 类型开关 (type switch) 比较类型而非值。可以用来发现一个接口值的类型。\n// 在这个例子中，变量 `t` 在每个分支中会有相应的类型。 whatAmI := func(i interface{}) { switch t := i.(type) { case bool: fmt.Println(\u0026#34;I\u0026#39;m a bool\u0026#34;) case int: fmt.Println(\u0026#34;I\u0026#39;m an int\u0026#34;) default: fmt.Printf(\u0026#34;Don\u0026#39;t know type %T\\n\u0026#34;, t) } } whatAmI(true) whatAmI(1) whatAmI(\u0026#34;hey\u0026#34;)  map //创建一个空 map m := make(map[string]int) m[\u0026#34;k1\u0026#34;] = 7 m[\u0026#34;k2\u0026#34;] = 13 // 内建函数 `delete` 可以从一个 map 中移除键值对 delete(m, \u0026#34;k2\u0026#34;) // 可以 选择 使用第二个参数，判断是否存在 key v2, ok := m[\u0026#34;k2\u0026#34;] // 声明并初始化 n := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2} range kvs := map[string]string{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2} for k, v := range kvs { } // `range` 也可以只遍历 map 的键 for k := range kvs { } // `range` 在字符串中迭代 unicode 码点(code point)。 // 第一个返回值是字符的起始字节位置，然后第二个是字符本身。 // 输出： // 0 103 // 1 111 // 2 103 // 3 111 for i, c := range \u0026#34;gogo\u0026#34; { fmt.Println(i, c) } // 输出： // 0 // 1 // 2 // 3 for i := range \u0026#34;gogo\u0026#34; { fmt.Println(i) } "});index.add({'id':27,'href':'/study-go/docs/basic/grammar/type/slice/','title':"切片",'content':"Go 切片 "});index.add({'id':28,'href':'/study-go/docs/basic/practice/package-manage/','title':"包管理",'content':"包管理 vendor modules GO111MODULE 为 on 使用 modules 功能，这种模式下，$GOPATH 不再作为 build 时导入的角色， 依赖包会存放在 $GOPATH/pkg/mod 目录下。\nGO111MODULE 为 off  优先使用 vendor 目录下面的包， 如果 vendor 下面没有搜索到，再搜索 $GOPATH/src 下面的包， 如果 $GOPATH 下面没有搜索到，那么搜索 $GOROOT/src 下面的包  "});index.add({'id':29,'href':'/study-go/docs/basic/lib/','title':"库",'content':"Go 库 "});index.add({'id':30,'href':'/study-go/docs/basic/grammar/type/','title':"数据类型",'content':"Go 数据类型 基础数据类型 Pre-declarered types 布尔型  数字类型           uint8     uint16     uint32  0 到 4294967295 （42 亿）   uint64     int8 有符号 8 位整型 -128 到 127   int16 有符号 16 位整型 -32768 到 32767   int32  -2147483648 到 2147483647   int64     float32 IEEE-754 32 位浮点型数    float64 IEEE-754 64 位浮点型数    complex64 32 位实数和虚数    complex128 64 位实数和虚数    byte 类似 uint8    rune 类似 int32    uint 32 或 64 位    int 与 uint 一样大小    uintptr 无符号整型，用于存放一个指针     uint 不能直接相减 结果是负数会变成一个很大的 uint，这点对动态语言出身的可能有坑\n 字符串类型  派生类型 Composite Types 指针类型（Pointer） 数组类型 结构化类型 (struct) go struct 能不能比较？\n 因为是强类型语言，所以不同类型的结构不能作比较， 但是同一类型的实例值是可以比较的， 实例不可以比较，因为是指针类型。  Channel 类型 函数类型 切片类型 如果你要创建一个很长的 slice，尽量创建成一个 slice 里存引用，这样可以分批释放，避免 gc 在低配机器上 stop the world\n从 slice 创建 slice 的时候，注意原 slice 的操作可能导致底层数组变化\nJSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？\n多维 slice Slice 可以组成多维数据结构。\n内部的 slice 长度可以不一致，这一点和多维数组不同。\n 接口类型（interface） Map 类型 m := make(map[string]string)  类型转化 Atoi // string 到 int int, err := strconv.Atoi(string) // string 到 int64 int64, err := strconv.ParseInt(string, 10, 64) // int 到 string string := strconv.Itoa(int) // int64 到 string string := strconv.FormatInt(int64, 10) "});index.add({'id':31,'href':'/study-go/docs/basic/grammar/type/array/','title':"数组",'content':"Go 数组 "});index.add({'id':32,'href':'/study-go/docs/basic/practice/compile/','title':"编译",'content':"编译 交叉编译 golang 交叉编译很简单的，只要设置几个环境变量就可以了\n# mac上编译linux和windows二进制 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # linux上编译mac和windows二进制 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # windows上编译mac和linux二进制 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go "});index.add({'id':33,'href':'/study-go/docs/basic/practice/pattern/','title':"Go 设计模式",'content':"Go 设计模式 "});index.add({'id':34,'href':'/study-go/docs/basic/grammar/type/interface/','title':"Interface",'content':"Go Interface "});index.add({'id':35,'href':'/study-go/docs/basic/grammar/func/','title':"函数",'content':"函数 函数参数 值传递 golang 中函数的参数传递采用的是值传递。\n在处理 map，channel 和 slice 等这些内置结构的数据时，其实处理的是一个指针类型的数据。\n可变参数 package main import \u0026#34;fmt\u0026#34; // 这个函数接受任意数量的 `int` 作为参数。 func sum(nums ...int) { fmt.Print(nums, \u0026#34; \u0026#34;) total := 0 for _, num := range nums { total += num } fmt.Println(total) } func main() { // 变参函数使用常规的调用方式，传入独立的参数。 \tsum(1, 2) sum(1, 2, 3) // 如果你有一个含有多个值的 slice，想把它们作为参数使用， \t// 你需要这样调用 `func(slice...)`。 \tnums := []int{1, 2, 3, 4} sum(nums...) }  方法 调用方法时产生一个拷贝 r := rect{width: 10, height: 5} // 调用方法时，Go 会自动处理值和指针之间的转换。 // 想要避免在调用方法时产生一个拷贝，或者想让方法可以修改接受结构体的值， // 你都可以使用指针来调用方法。 rp := \u0026amp;r fmt.Println(\u0026#34;area: \u0026#34;, rp.area()) fmt.Println(\u0026#34;perim:\u0026#34;, rp.perim()) "});index.add({'id':36,'href':'/study-go/docs/basic/practice/algs/','title':"Go 算法实现",'content':"Go 算法实现 "});index.add({'id':37,'href':'/study-go/docs/basic/grammar/type/channel/','title':"Chiannel",'content':"Chiannel channel 类型 chan T // can be used to send and receive values of type T chan\u0026lt;- float64 // can only be used to send float64s \u0026lt;-chan int // can only be used to receive ints The \u0026lt;- operator associates with the leftmost chan possible:\nchan\u0026lt;- chan int // same as chan\u0026lt;- (chan int) chan\u0026lt;- \u0026lt;-chan int // same as chan\u0026lt;- (\u0026lt;-chan int) \u0026lt;-chan \u0026lt;-chan int // same as \u0026lt;-chan (\u0026lt;-chan int) chan (\u0026lt;-chan int)  常见用法 // 使用 `make(chan val-type)` 创建一个新的通道。 // 通道类型就是他们需要传递值的类型。 messages := make(chan string) // 使用 `channel \u0026lt;-` 语法 _发送_ 一个新的值到通道中。 // 这里我们在一个新的协程中发送 `\u0026#34;ping\u0026#34;` 到上面创建的 `messages` 通道中。 go func() { messages \u0026lt;- \u0026#34;ping\u0026#34; }() // 使用 `\u0026lt;-channel` 语法从通道中 _接收_ 一个值。 // 这里我们会收到在上面发送的 `\u0026#34;ping\u0026#34;` 消息并将其打印出来。 msg := \u0026lt;-messages fmt.Println(msg) // 如果 ok 的值是 false，表明 接收到的是 特别制造的 0 值 —— 因为发送通道关闭了并且为空（closed and empty）。 msg, ok := \u0026lt;-messages done channel 用于保证流水线上每个阶段 goroutine 的退出\ngolang.org/x/net/context/ctxhttp 中 Do 方法的实现：\n// https://github.com/golang/net/blob/release-branch.go1.7/context/ctxhttp/ctxhttp.go  // Do sends an HTTP request with the provided http.Client and returns // an HTTP response. // // If the client is nil, http.DefaultClient is used. // // The provided ctx must be non-nil. If it is canceled or times out, // ctx.Err() will be returned. func Do(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) { if client == nil { client = http.DefaultClient } resp, err := client.Do(req.WithContext(ctx)) // If we got an error, and the context has been canceled,  // the context\u0026#39;s error is probably more useful.  if err != nil { select { case \u0026lt;-ctx.Done(): err = ctx.Err() default: } } return resp, err }  注意点  无缓冲 chan 的发送和接收是否同步 channel 一定记得 close channel 是通过注册相关 goroutine id 实现消息通知的  关闭 channel  不要从接收端关闭 channel 不要关闭有多个并发发送者的 channel  如果 sender 是唯一的 sender 或是 channel 最后一个活跃的 sender， 那么你应该在 sender 的 goroutine 关闭 channel， 从而通知 receiver (s)(接收者们) 已经没有值可以读了。\n// _关闭_ 一个通道意味着不能再向这个通道发送值了。 // 该特性可以向通道的接收方传达工作已经完成的信息。  package main import \u0026#34;fmt\u0026#34; // 在这个例子中，我们将使用一个 `jobs` 通道，将工作内容， // 从 `main()` 协程传递到一个工作协程中。 // 当我们没有更多的任务传递给工作协程时，我们将 `close` 这个 `jobs` 通道。 func main() { jobs := make(chan int, 5) done := make(chan bool) // 这是工作协程。使用 `j, more := \u0026lt;- jobs` 循环的从 `jobs` 接收数据。 \t// 根据接收的第二个值，如果 `jobs` 已经关闭了， \t// 并且通道中所有的值都已经接收完毕，那么 `more` 的值将是 `false`。 \t// 当我们完成所有的任务时，会使用这个特性通过 `done` 通道通知 main 协程。 \tgo func() { for { j, more := \u0026lt;-jobs if more { fmt.Println(\u0026#34;received job\u0026#34;, j) } else { fmt.Println(\u0026#34;received all jobs\u0026#34;) done \u0026lt;- true return } } }() // 使用 `jobs` 发送 3 个任务到工作协程中，然后关闭 `jobs`。 \tfor j := 1; j \u0026lt;= 3; j++ { jobs \u0026lt;- j fmt.Println(\u0026#34;sent job\u0026#34;, j) } close(jobs) fmt.Println(\u0026#34;sent all jobs\u0026#34;) // 使用前面学到的[通道同步](channel-synchronization)方法等待任务结束。 \t\u0026lt;-done } 参考：\n 如何优雅地关闭 Go channel  Golang chan 避免死锁 Golang 的管道 (chan) 无论是否有缓冲，生产者和消费者不可能做到完全解耦， 一旦管道满了，就相当于生产者直接调用消费者。\n如果生产者和消费者使用同一个锁，就是死锁了.\n所以，一个重要的原则就是，在写管道之前，把所有可能的锁 unlock 掉.\nRelated posts:\n 异步编程语言的常见坑 CVPixelBufferRef 与 CVOpenGLTextureRef: 图像处理中内存与显存的交互 集成于 iphp 框架的 PHP 并发模型和工具 蛇形遍历数组 流式布局的原理和代码实现  参考  Golang chan 避免死锁  "});index.add({'id':38,'href':'/study-go/docs/basic/grammar/make/','title':"make",'content':"make 运算符:= 是 make() 的语法糖\n"});index.add({'id':39,'href':'/study-go/docs/basic/grammar/type/map/','title':"Map",'content':"Map Golang 中的 map，实际上就是一个 hashtable\n在 golang 中，当 map 作为形参时，虽然是值传递，但是由于 make () 返回的是一个指针类型\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. func makemap(t *maptype, hint int, h *hmap) *hmap { if hint \u0026lt; 0 || hint \u0026gt; int(maxSliceCap(t.bucket.size)) { hint = 0 } ... } "});index.add({'id':40,'href':'/study-go/docs/basic/grammar/select/','title':"select",'content':"select Go 的 选择器（select） 让你可以同时等待多个通道操作。\n将协程、通道和选择器结合，是 Go 的一个强大特性。\n// 在这个例子中，我们将从两个通道中选择。 c1 := make(chan string) c2 := make(chan string) // 各个通道将在一定时间后接收一个值， // 通过这种方式来模拟并行的协程执行（例如，RPC 操作）时造成的阻塞（耗时）。 go func() { time.Sleep(1 * time.Second) c1 \u0026lt;- \u0026#34;one\u0026#34; }() go func() { time.Sleep(2 * time.Second) c2 \u0026lt;- \u0026#34;two\u0026#34; }() // 我们使用 `select` 关键字来同时等待这两个值， // 并打印各自接收到的值。 for i := 0; i \u0026lt; 2; i++ { select { case msg1 := \u0026lt;-c1: fmt.Println(\u0026#34;received\u0026#34;, msg1) case msg2 := \u0026lt;-c2: fmt.Println(\u0026#34;received\u0026#34;, msg2) } } 随机选则 除 default 外，如果有多个 case 语句评估通过，那么通过伪随机的方式随机选一个\n非阻塞 default 为空 func sendTime(c interface{}, seq uintptr) { // Non-blocking send of time on c. \t// Used in NewTimer, it cannot block anyway (buffer). \t// Used in NewTicker, dropping sends on the floor is \t// the desired behavior when the reader gets behind, \t// because the sends are periodic. \tselect { case c.(chan Time) \u0026lt;- Now(): default: } } "});index.add({'id':41,'href':'/study-go/docs/basic/practice/snippet/','title':"代码片段",'content':"代码片段 slice // 最前面插入一个元素 x = append([]int{1}, x...) // An allocation is only necessary when there is no spare slice capacity. x = append(x, 0) copy(x[1:], x) x[0] = 1 参考： How to prepend int to slice\n"});index.add({'id':42,'href':'/study-go/docs/basic/lib/std/sync/cond/','title':"Cond",'content':"Cond type Cond struct { // L is held while observing or changing the condition \tL Locker // contains filtered or unexported fields } func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait()  条件  一个条件一定要有一个信号   信号  wait 等待的是信号 signal 发送的是信号 一个信号可以对应到多个条件    "});index.add({'id':43,'href':'/study-go/docs/basic/grammar/goroutine/','title':"goroutine",'content':"goroutine golang 并发模型 goroutine 记得 return 或者中断，不然容易造成 goroutine 占用大量 CPU "});index.add({'id':44,'href':'/study-go/docs/basic/lib/std/sync/mutex/','title':"Mutex",'content':"Mutex Mutex 互斥锁  在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex 使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁  在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁   在 Lock() 之前使用 Unlock() 会导致 panic 异常 已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁 适用于读写不确定，并且只有一个读或者写的场景  type Mutex struct { // contains filtered or unexported fields } func (m *Mutex) Lock() func (m *Mutex) Unlock() RWMutex 读写锁（读多写少） RWMutex 基于 Mutex 实现\n RWMutex 是单写多读锁，该锁可以加一个写锁或者多个读锁 写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占  Lock() 加写锁，Unlock() 解写锁 在 Lock() 之前使用 Unlock() 会导致 panic 异常 如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定   读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁  RLock() 加读锁，RUnlock() 解读锁 RLock() 加读锁时，如果存在写锁，则无法加读锁 在没有读锁的情况下调用 RUnlock() 会导致 panic 错误  RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误     适用于读多写少的场景  "});index.add({'id':45,'href':'/study-go/docs/basic/lib/std/signal/','title':"signal",'content':"signal The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.\nBy default, a synchronous signal is converted into a run-time panic.\nA SIGHUP, SIGINT, or SIGTERM signal causes the program to exit.\nA SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit with a stack dump.\nA SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default behavior (these signals are used by the shell for job control).\nThe SIGPROF signal is handled directly by the Go runtime to implement runtime.CPUProfile.\nOther signals will be caught but no action will be taken.\nSynchronous signals  SIGBUS 7 SIGFPE 8 SIGSEGV 11  These are only considered synchronous when caused by program execution, not when sent using os.Process.Kill or the kill program or some similar mechanism.\nGo programs will convert a synchronous signal into a run-time panic.\nAsynchronous signals  SIGTERM 15  kill 默认不带参数，发送的信号就是 SIGTERM 可以被阻塞、处理和忽略   SIGINT 2  the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C).   SIGHUP 1  a program loses its controlling terminal   SIGQUIT 3  the user at the controlling terminal presses the quit character, which by default is ^\\ (Control-Backslash)   SIGILL 4  执行了非法指令    The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.\n func Notify // Set up channel on which to send signal notifications. // We must use a buffered channel or risk missing the signal // if we\u0026#39;re not ready to receive when the signal is sent. c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) // Block until a signal is received. s := \u0026lt;-c fmt.Println(\u0026#34;Got signal:\u0026#34;, s) "});index.add({'id':46,'href':'/study-go/docs/basic/lib/std/sync/','title':"sync",'content':"sync 锁的类型 Mutex RWMutex WaitGroup "});index.add({'id':47,'href':'/study-go/docs/basic/lib/std/time/','title':"time",'content':"time 格式化 // 1 2 3 4 5 6 const ANSIC = \u0026#34;Mon Jan _2 15:04:05 2006\u0026#34; time.Now().Format(\u0026#34;2006-01-02 15:04:05\u0026#34;) "});index.add({'id':48,'href':'/study-go/docs/basic/practice/version/','title':"版本",'content':"Go 版本 golang/go  版本控制 moovweb/gvm  安装：\nzsh \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 版本历史 1.14 (2020/02/25) 1.14 (2020/02/25) 1.13 (2019/09/03) 1.12 (2019/02/25) 1.11 (2018/08/24) 1.10 (2018/02/16) 1.9 (2017/08/24) 1.8 (2017/02/16) 1.7 (2016/08/15) 1.6 (2016/02/17) 1.5 (2015/08/19) Go 1.5 开始，使用 Go 自举实现。\n1.4 (2014/12/10) Go 1.4 之前是 C 实现。\n1.3 (2014/06/18) 1.2 (2013/12/01) 1.1 (2013/05/13) 1 (2012/03/28) "});index.add({'id':49,'href':'/study-go/docs/appendix/attention/','title':"关注",'content':"关注 golang/go  kubernetes/kubernetes  moby/moby  etcd-io/etcd  Distributed reliable key-value store for the most critical data of a distributed system\ncontainous/traefik  The Cloud Native Edge Router https://traefik.io\n Web 框架 gin-gonic/gin  Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance \u0026ndash; up to 40 times faster. If you need smashing performance, get yourself some Gin. https://gin-gonic.com/\nastaxie/beego  beego is an open-source, high-performance web framework for the Go programming language.\n 工具 junegunn/fzf  A command-line fuzzy finder\n模糊查询\n 其他 avelino/awesome-go  fatedier/frp  A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.\ngogs/gogs  Gogs is a painless self-hosted Git service\ncaddyserver/caddy  Fast, multi-platform web server with automatic HTTPS\nfzf is a general-purpose command-line fuzzy finder.\naceld/zinx  基于 Golang 轻量级 TCP 并发服务器框架\ngolang/glog  Leveled execution logs for Go\nc-bata/go-prompt  Building powerful interactive prompts in Go, inspired by python-prompt-toolkit.\n"});index.add({'id':50,'href':'/study-go/docs/basic/practice/','title':"实践",'content':"Go 实践 "});index.add({'id':51,'href':'/study-go/docs/basic/practice/log/','title':"日志",'content':"Go 日志 开源实现 sirupsen/logrus  Structured, pluggable logging for Go.\ngolang/glog  Leveled execution logs for Go\n"});index.add({'id':52,'href':'/study-go/docs/basic/practice/best/','title':"最佳实践",'content':"Go 最佳实践 "});index.add({'id':53,'href':'/study-go/docs/basic/practice/test/','title':"测试",'content':"Go 测试 开源实现 onsi/ginkgo  BDD Testing Framework for Go\n"});index.add({'id':54,'href':'/study-go/docs/appendix/interview/','title':"面试题",'content':"Go 语言面试题 基础题 进阶题 高阶题 综合  你遇到过哪些高质量的 Go 语言面试题？ shomali11/go-interview go 算法实现  "});index.add({'id':55,'href':'/study-go/docs/','title':"Docs",'content':""});})();
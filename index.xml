<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>首页 on Go 学习笔记</title>
    <link>https://ikingye.github.io/study-go/</link>
    <description>Recent content in 首页 on Go 学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://ikingye.github.io/study-go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>百度</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/spec/baidu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/spec/baidu/</guid>
      <description>百度 Golang 编码规范 V1.2 </description>
    </item>
    
    <item>
      <title>基础</title>
      <link>https://ikingye.github.io/study-go/docs/appendix/interview/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/appendix/interview/basic/</guid>
      <description>基础面试题 </description>
    </item>
    
    <item>
      <title>常用 package</title>
      <link>https://ikingye.github.io/study-go/docs/basic/lib/common/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/lib/common/</guid>
      <description>Go 常用 package net imroc/req  Go 语言人性化 HTTP 请求库
 cmd spf13/cobra  A Commander for modern Go CLI interactions
quick start typically a Cobra-based application will follow the following organizational structure:
▾ appName/ ▾ cmd/ add.go your.go commands.go here.go main.go In a Cobra app, typically the main.go file is very bare. It serves one purpose: initializing Cobra.
package main import ( &amp;#34;{pathToYourApp}/cmd&amp;#34; ) func main() { cmd.Execute() } Ideally you place this in app/cmd/root.</description>
    </item>
    
    <item>
      <title>进阶</title>
      <link>https://ikingye.github.io/study-go/docs/appendix/interview/advanced/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/appendix/interview/advanced/</guid>
      <description>进阶面试题 </description>
    </item>
    
    <item>
      <title>高阶</title>
      <link>https://ikingye.github.io/study-go/docs/appendix/interview/expert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/appendix/interview/expert/</guid>
      <description>高阶面试题 </description>
    </item>
    
    <item>
      <title>Go 初始化</title>
      <link>https://ikingye.github.io/study-go/docs/design/runtime/init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/design/runtime/init/</guid>
      <description>Go 初始化 golang 程序初始化先于 main 函数执行，由 runtime 进行初始化，初始化顺序如下：
 初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime 需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见 golang 变量的初始化）； 初始化包作用域的变量（该作用域的变量的初始化也并非按照 “从上到下、从左到右” 的顺序，runtime 解析变量依赖关系，没有依赖的变量最先初始化，参见 golang 变量的初始化）； 执行包的 init 函数；   变量初始化 -&amp;gt;init ()-&amp;gt;main () 由于 pack 包的初始化依赖 test_util，因此运行时先初始化 test_util 再初始化 pack 包；   同一个包不同源文件的 init 函数执行顺序，golang spec 没做说明  一般是源文件名称的字典序，但不能依赖这个假定     在每一个初始化周期，运行时（runtime）会挑选一个没有任何依赖的变量初始化  该过程一直持续到所有的变量均被初始化或者出现依赖嵌套的情形   同一个 package 下多个文件的变量初始化依赖也遵循相同的规则   变量初始化 不同作用域类型的变量初始化顺序不同
函数作用域内的局部变量 初始化顺序：从左到右、从上到下
package 级别的变量 初始化顺序与初始化依赖有关
 </description>
    </item>
    
    <item>
      <title>Go 命令</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/command/</guid>
      <description>Go 命令 go get go get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages] go get -d go get -d library 表示只下载，不安装
go get == go install go get -d == go list The -d flag instructs get to download the source code needed to build the named packages, including downloading necessary dependencies, but not to build and install them.
With no package arguments, &amp;lsquo;go get&amp;rsquo; applies to Go package in the current directory, if any.</description>
    </item>
    
    <item>
      <title>Go 调度</title>
      <link>https://ikingye.github.io/study-go/docs/design/scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/design/scheduling/</guid>
      <description>Go 调度 参考 Scheduling In Go  Scheduling In Go : Part I - OS Scheduler Scheduling In Go : Part II - Go Scheduler Scheduling In Go : Part III - Concurrency  Garbage Collection In Go  Garbage Collection In Go : Part I - Semantics Garbage Collection In Go : Part II - GC Traces Garbage Collection In Go : Part III - GC Pacing  </description>
    </item>
    
    <item>
      <title>init</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/func/init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/func/init/</guid>
      <description>init 函数  作用  初始化不能采用初始化表达式初始化的变量 程序运行前的注册 实现 sync.Once 功能   特点  init 函数先于 main 函数自动执行 init 不能被其他函数调用 init 函数没有输入参数、返回值 每个包可以有多个 init 函数  包的每个源文件也可以有多个 init 函数   同一个包的 init 执行顺序，golang 没有明确定义，编程时要注意程序不要依赖这个执行顺序 不同包的 init 函数按照包导入的依赖关系决定执行顺序   问答 只想调用该包的 init 函数，不使用包导出的变量或者方法 import _ &amp;#34;net/http/pprof&amp;#34; 执行上述导入后，init 函数会启动一个异步协程采集该进程实例的资源占用情况，并以 http 服务接口方式提供给用户查询。
 参考 </description>
    </item>
    
    <item>
      <title>interface</title>
      <link>https://ikingye.github.io/study-go/docs/design/interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/design/interface/</guid>
      <description>interface Go Data Structures: Interfaces
读完这篇 go 作者的 blog，interface 就没什么秘密可言了。每个 interface 至少包含两个字段，type 和 data，不论什么形式，然后是 itable 什么时候生成，如何调用。
结合 Comparison operators，记住 interface 的 compare 规则。</description>
    </item>
    
    <item>
      <title>Receiver</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/func/receiver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/func/receiver/</guid>
      <description>Receiver 结构体类型实现的接口，该结构体的指针类型也算实现了
使用规则  必须使用指针  struct，且包含 sync.Mutex 类型字段   建议使用指针  比较大的 struct/array  struct 或者 array 中的元素个数超过 3 个，则认为比较大，反之，则认为比较小   struct、array 或 slice，其中指针元素所指的内容可能在方法内被修改   建议使用 value 类型  比较小的 struct/array   必须使用 value 类型（编程规范）  map、函数或者 chan 类型 slice，并且方法不会进行 reslice 或者重新分配 slice    method expression package main import ( &amp;#34;fmt&amp;#34; ) type Ball struct { Name string } func (b *Ball) Ping() { fmt.</description>
    </item>
    
    <item>
      <title>优劣</title>
      <link>https://ikingye.github.io/study-go/docs/design/pros-and-cons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/design/pros-and-cons/</guid>
      <description>Go 语言优劣 Go 的优点 部署简单  直接编译成机器码 不依赖其他库 直接运行即可部署  静态类型语言 编译时可检测出隐藏的大多数问题
语言层面实现并发（goroutine） 强大的标准库  runtime 系统调度机制 高效的 GC（垃圾回收） 丰富的标准库  简单易学  25 个关键字 内嵌 C 语法支持（CGO） 面向对象 跨平台  背靠大厂（Google） 性能好  Go 的缺点 无泛化类型 传言 Go 2.0 会加上
无 Exception，都用 Error 有争议
包管理大部分在 Github 参考：
 2020 年以后是 Go 的天下吗？  </description>
    </item>
    
    <item>
      <title>关键字</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/keyword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/keyword/</guid>
      <description>Go 语言关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var for 与 range select defer panic 与 recover make 与 new </description>
    </item>
    
    <item>
      <title>教程</title>
      <link>https://ikingye.github.io/study-go/docs/appendix/tutorial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/appendix/tutorial/</guid>
      <description>Go 教程 基础 astaxie/build-web-application-with-golang  A golang ebook intro how to build a web with golang
mmcgrana/gobyexample  Go by Example
中文翻译：通过例子学 Golang：https://gobyexample-cn.github.io/
geektutu/7days-golang  7 天用 Go 动手写 / 从零实现系列
golang101/golang101  Go 语言 101 : 一本侧重于 Go 语言语法和语义的编程解释和指导书 https://gfw.go101.org
 练习 ardanlabs/gotraining  Go Training Class Material : http://www.ArdanLabs.com
进阶 Go 语言设计与实现 by Draveness 高阶 </description>
    </item>
    
    <item>
      <title>类型系统</title>
      <link>https://ikingye.github.io/study-go/docs/design/type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/design/type/</guid>
      <description>Go 类型系统 Underlying Type  每一个类型都有自己的 Underlying Type  如果 T 是 Pre-declared type 或者 Type Literal，它们对应的 Underlying Type 就是自身 T  比如 type T int 的 Underlying Type 是 int  int 是 Pre-declared   type T map[int]string 的 Underlying Type 是 map[int]string  map[int]string 是 Type Literal     否则 T 的 Underlying Type 是 T 定义时引用的类型的 Underlying Type    Underlying Type 相同 如果两个 type 的 Underlying Type 相同，则它们可以有以下特性：</description>
    </item>
    
    <item>
      <title>编译</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/compile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/compile/</guid>
      <description>编译 交叉编译 golang 交叉编译很简单的，只要设置几个环境变量就可以了
# mac上编译linux和windows二进制 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # linux上编译mac和windows二进制 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # windows上编译mac和linux二进制 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go </description>
    </item>
    
    <item>
      <title>Interface</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/type/interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/type/interface/</guid>
      <description>Go Interface </description>
    </item>
    
    <item>
      <title>Chiannel</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/type/channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/type/channel/</guid>
      <description>Chiannel channel 类型 chan T // can be used to send and receive values of type T chan&amp;lt;- float64 // can only be used to send float64s &amp;lt;-chan int // can only be used to receive ints The &amp;lt;- operator associates with the leftmost chan possible:
chan&amp;lt;- chan int // same as chan&amp;lt;- (chan int) chan&amp;lt;- &amp;lt;-chan int // same as chan&amp;lt;- (&amp;lt;-chan int) &amp;lt;-chan &amp;lt;-chan int // same as &amp;lt;-chan (&amp;lt;-chan int) chan (&amp;lt;-chan int)  常见用法 // 使用 `make(chan val-type)` 创建一个新的通道。 // 通道类型就是他们需要传递值的类型。 messages := make(chan string) // 使用 `channel &amp;lt;-` 语法 _发送_ 一个新的值到通道中。 // 这里我们在一个新的协程中发送 `&amp;#34;ping&amp;#34;` 到上面创建的 `messages` 通道中。 go func() { messages &amp;lt;- &amp;#34;ping&amp;#34; }() // 使用 `&amp;lt;-channel` 语法从通道中 _接收_ 一个值。 // 这里我们会收到在上面发送的 `&amp;#34;ping&amp;#34;` 消息并将其打印出来。 msg := &amp;lt;-messages fmt.</description>
    </item>
    
    <item>
      <title>make</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/make/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/make/</guid>
      <description>make 运算符:= 是 make() 的语法糖</description>
    </item>
    
    <item>
      <title>Map</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/type/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/type/map/</guid>
      <description>Map Golang 中的 map，实际上就是一个 hashtable
在 golang 中，当 map 作为形参时，虽然是值传递，但是由于 make () 返回的是一个指针类型
// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket.</description>
    </item>
    
    <item>
      <title>select</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/select/</guid>
      <description>select Go 的 选择器（select） 让你可以同时等待多个通道操作。
将协程、通道和选择器结合，是 Go 的一个强大特性。
// 在这个例子中，我们将从两个通道中选择。 c1 := make(chan string) c2 := make(chan string) // 各个通道将在一定时间后接收一个值， // 通过这种方式来模拟并行的协程执行（例如，RPC 操作）时造成的阻塞（耗时）。 go func() { time.Sleep(1 * time.Second) c1 &amp;lt;- &amp;#34;one&amp;#34; }() go func() { time.Sleep(2 * time.Second) c2 &amp;lt;- &amp;#34;two&amp;#34; }() // 我们使用 `select` 关键字来同时等待这两个值， // 并打印各自接收到的值。 for i := 0; i &amp;lt; 2; i++ { select { case msg1 := &amp;lt;-c1: fmt.Println(&amp;#34;received&amp;#34;, msg1) case msg2 := &amp;lt;-c2: fmt.</description>
    </item>
    
    <item>
      <title>goroutine</title>
      <link>https://ikingye.github.io/study-go/docs/basic/grammar/goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/grammar/goroutine/</guid>
      <description>goroutine golang 并发模型 goroutine 记得 return 或者中断，不然容易造成 goroutine 占用大量 CPU </description>
    </item>
    
    <item>
      <title>Mutex</title>
      <link>https://ikingye.github.io/study-go/docs/basic/lib/std/sync/mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/lib/std/sync/mutex/</guid>
      <description>Mutex Mutex 互斥锁  在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex 使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁  在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁   在 Lock() 之前使用 Unlock() 会导致 panic 异常 已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁 适用于读写不确定，并且只有一个读或者写的场景  type Mutex struct { // contains filtered or unexported fields } func (m *Mutex) Lock() func (m *Mutex) Unlock() RWMutex 读写锁（读多写少） RWMutex 基于 Mutex 实现</description>
    </item>
    
    <item>
      <title>signal</title>
      <link>https://ikingye.github.io/study-go/docs/basic/lib/std/signal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/lib/std/signal/</guid>
      <description>signal The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.
By default, a synchronous signal is converted into a run-time panic.
A SIGHUP, SIGINT, or SIGTERM signal causes the program to exit.
A SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit with a stack dump.
A SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default behavior (these signals are used by the shell for job control).</description>
    </item>
    
    <item>
      <title>time</title>
      <link>https://ikingye.github.io/study-go/docs/basic/lib/std/time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/lib/std/time/</guid>
      <description>time 格式化 // 1 2 3 4 5 6 const ANSIC = &amp;#34;Mon Jan _2 15:04:05 2006&amp;#34; time.Now().Format(&amp;#34;2006-01-02 15:04:05&amp;#34;) </description>
    </item>
    
    <item>
      <title>关注</title>
      <link>https://ikingye.github.io/study-go/docs/appendix/attention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/appendix/attention/</guid>
      <description>关注 golang/go  kubernetes/kubernetes  moby/moby  etcd-io/etcd  Distributed reliable key-value store for the most critical data of a distributed system
containous/traefik  The Cloud Native Edge Router https://traefik.io
 Web 框架 gin-gonic/gin  Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance &amp;ndash; up to 40 times faster. If you need smashing performance, get yourself some Gin. https://gin-gonic.com/</description>
    </item>
    
    <item>
      <title>日志</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/log/</guid>
      <description>Go 日志 开源实现 sirupsen/logrus  Structured, pluggable logging for Go.
golang/glog  Leveled execution logs for Go</description>
    </item>
    
    <item>
      <title>最佳实践</title>
      <link>https://ikingye.github.io/study-go/docs/basic/practice/best/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-go/docs/basic/practice/best/</guid>
      <description>Go 最佳实践 </description>
    </item>
    
  </channel>
</rss>
'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-go/docs/basic/pkg/std/','title':"标准库",'content':"Go 标准库 "});index.add({'id':1,'href':'/study-go/docs/basic/practice/spec/baidu/','title':"百度",'content':"百度 Golang 编码规范 V1.2 "});index.add({'id':2,'href':'/study-go/docs/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':3,'href':'/study-go/docs/basic/practice/spec/','title':"编程规范",'content':"Go 编程规范 代码组织 建议文件按以下顺序进行布局：\n General Documentation: 对整个模块和功能的完整描述注释，写在文件头部。 package: 当前 package 定义 imports: 包含的头文件 Constants: 常量 Typedefs: 类型定义 Globals: 全局变量定义 functions: 函数实现   语言规范 申明 slice 申明 slice 时，建议使用 var 方式申明，不建议使用大括号的方式\n// GOOD: var t []string // BAD: t := []string{} embedding  embedding 只用于 \u0026ldquo;is a\u0026rdquo; 的语义下，而不用于 \u0026ldquo;has a\u0026rdquo; 的语义下  语义上 embedding 是一种继承关系，而不是成员关系   一个定义内，多于一个的 embedding 尽量少用  一个定义内有多个 embedding，则很难判断某个成员变量或函数是从哪里继承得到的 一个定义内有多个 embedding，危害和在 python 中使用 from xxx import * 是类似的    type Automobile struct { // ... } type Engine struct { // .... } // GOOD: type Car struct { Automobile // Car is a Automobile  engine Engine // Car has a Engine } // BAD: type Car struct { Automobile // Car is a Automobile  Engine // Car has a Engine, but Car is NOT a Engine } 函数参数和返回值   必须\n 函数返回值小于等于 3 个，大于 3 个时必须通过 struct 进行包装    建议\n 函数参数不建议超过 3 个，大于 3 个时建议通过 struct 进行包装 函数返回值  逻辑判断型：返回值的意义代表 “真” 或 “假”，返回值类型定义为 bool 操作型：返回值的意义代表 “成功” 或 “失败”，返回值类型定义为 error 获取数据型：返回值的意义代表 “有数据” 或 “无数据 / 获取数据失败”，返回值类型定义为（data, error）      缩进  使用 tab 进行缩进。 跨行的缩进使用 gofmt 的缩进方式。 设置 tabstop=4  空格  圆括号、方括号、花括号内侧都不加空格 逗号、冒号（slice 中冒号除外）前不加空格，后边加一个空格 所有二元运算符前后各加一个空格（作为函数参数时除外）  var ( s = make([]int, 10) ) // GOOD： func foo() { m := map[string]string{\u0026#34;language\u0026#34;: \u0026#34;golang\u0026#34;} r := 1 + 2 func1(1+2) fmt.Println(m[\u0026#34;language\u0026#34;]) } // BAD： func foo() { m := map[string]string{ \u0026#34;language\u0026#34; : \u0026#34;golang\u0026#34; } r := 1+2 func1(1 + 2) fmt.Println(m[ \u0026#34;language\u0026#34; ]) }  命名 文件名 文件名都使用小写字母，如果需要，可以使用下划线分割\n文件名的后缀使用小写字母\n函数名 / 变量名 采用驼峰方式命名，禁止使用下划线命名\n首字母是否大写，根据是否需要外部访问来决定\n常量 尽量不要在程序中直接写数字，特殊字符串，全部用常量替代\n 编程实践 error string error string 尽量使用小写字母，并且结尾不带标点符号\nDon\u0026rsquo;t panic 除非出现不可恢复的程序错误，不要使用 panic，用多返回值和 error。\n关于 lock 的保护  如果临界区内的逻辑较复杂、无法完全避免 panic 的发生，则要求适用 defer 来调用 Unlock，即使在临界区过程中发生了 panic，也会在函数退出时调用 Unlock 释放锁  go 提供了 recover，可以对 panic 进行捕获，但如果 panic 发生在临界区内，则可能导致对锁的使用没有释放 这种情况下，即使 panic 不会导致整个程序的奔溃，也会由于” 锁不释放 “的问题而使临界区无法被后续的调用访问     上述操作如果造成临界区扩大后，需要建立单独的一个函数访问临界区。  func doDemo() { lock.Lock() // step1: 临界区内的操作  lock.Unlock() // step2: 临界区外的操作 } // 如果改造为 defer 的方式，变为如下代码，实际上扩大了临界区的范围（step2 的操作也被放置在临界区了） func doDemo() { lock.Lock() defer lock.Unlock() // step1: 临界区内的操作  // step2: 临界区外的操作 } // 需要使用单独的匿名函数，专门用于访问临界区 func doDemo() { func() { lock.Lock() defer lock.Unlock() // step1: 临界区内的操作操作  }() // step2: 临界区外的操作 } unsafe package  除非特殊原因，不建议使用 unsafe package  比如进行指针和数值 uintptr 之间转换就是一个特殊原因    "});index.add({'id':4,'href':'/study-go/docs/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':5,'href':'/study-go/docs/basic/pkg/common/','title':"常用 package",'content':"Go 常用 package net imroc/req  Go 语言人性化 HTTP 请求库\n cmd spf13/cobra  A Commander for modern Go CLI interactions\nquick start typically a Cobra-based application will follow the following organizational structure:\n▾ appName/ ▾ cmd/ add.go your.go commands.go here.go main.go In a Cobra app, typically the main.go file is very bare. It serves one purpose: initializing Cobra.\npackage main import ( \u0026#34;{pathToYourApp}/cmd\u0026#34; ) func main() { cmd.Execute() } Ideally you place this in app/cmd/root.go:\nvar rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, Short: \u0026#34;Hugo is a very fast static site generator\u0026#34;, Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`, Run: func(cmd *cobra.Command, args []string) { // 在这里写应用逻辑  }, } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } }  web gorilla/mux  A powerful HTTP router and URL matcher for building Go web servers\ngithubnemo/CompileDaemon  Watches your .go files in a directory and invokes go build if a file changed.\nUsage:\n./CompileDaemon -directory=yourproject/\n其他 gomodule/redigo  Go client for Redis\ngo-redis/redis  Type-safe Redis client for Golang\nhttps://godoc.org/github.com/go-redis/redis\n"});index.add({'id':6,'href':'/study-go/docs/design/','title':"第二部分 设计",'content':""});index.add({'id':7,'href':'/study-go/docs/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':8,'href':'/study-go/docs/source/','title':"第三部分 源码实现",'content':"如无特殊说明，源码版本为 1.14.2  "});index.add({'id':9,'href':'/study-go/docs/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':10,'href':'/study-go/docs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':11,'href':'/study-go/docs/design/runtime/init/','title':"Go 初始化",'content':"Go 初始化 golang 程序初始化先于 main 函数执行，由 runtime 进行初始化，初始化顺序如下：\n 初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime 需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见 golang 变量的初始化）； 初始化包作用域的变量（该作用域的变量的初始化也并非按照 “从上到下、从左到右” 的顺序，runtime 解析变量依赖关系，没有依赖的变量最先初始化，参见 golang 变量的初始化）； 执行包的 init 函数；   变量初始化 -\u0026gt;init ()-\u0026gt;main () 由于 pack 包的初始化依赖 test_util，因此运行时先初始化 test_util 再初始化 pack 包；   同一个包不同源文件的 init 函数执行顺序，golang spec 没做说明  一般是源文件名称的字典序，但不能依赖这个假定     在每一个初始化周期，运行时（runtime）会挑选一个没有任何依赖的变量初始化  该过程一直持续到所有的变量均被初始化或者出现依赖嵌套的情形   同一个 package 下多个文件的变量初始化依赖也遵循相同的规则   变量初始化 不同作用域类型的变量初始化顺序不同\n函数作用域内的局部变量 初始化顺序：从左到右、从上到下\npackage 级别的变量 初始化顺序与初始化依赖有关\n "});index.add({'id':12,'href':'/study-go/docs/basic/practice/command/','title':"Go 命令",'content':"Go 命令 go get go get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages] go get -d go get -d library 表示只下载，不安装\ngo get == go install go get -d == go list The -d flag instructs get to download the source code needed to build the named packages, including downloading necessary dependencies, but not to build and install them.\nWith no package arguments, \u0026lsquo;go get\u0026rsquo; applies to Go package in the current directory, if any. In particular, \u0026lsquo;go get -u\u0026rsquo; and \u0026lsquo;go get -u=patch\u0026rsquo; update all the dependencies of that package. With no package arguments and also without -u, \u0026lsquo;go get\u0026rsquo; is not much more than \u0026lsquo;go install\u0026rsquo;, and \u0026lsquo;go get -d\u0026rsquo; not much more than \u0026lsquo;go list\u0026rsquo;.\n参考：\n What is the difference between go get and go install?   go list "});index.add({'id':13,'href':'/study-go/docs/design/scheduling/','title':"Go 调度",'content':"Go 调度 参考 Scheduling In Go  Scheduling In Go : Part I - OS Scheduler Scheduling In Go : Part II - Go Scheduler Scheduling In Go : Part III - Concurrency  Garbage Collection In Go  Garbage Collection In Go : Part I - Semantics Garbage Collection In Go : Part II - GC Traces Garbage Collection In Go : Part III - GC Pacing  "});index.add({'id':14,'href':'/study-go/docs/basic/grammar/func/init/','title':"init",'content':"init 函数  作用  初始化不能采用初始化表达式初始化的变量 程序运行前的注册 实现 sync.Once 功能   特点  init 函数先于 main 函数自动执行 init 不能被其他函数调用 init 函数没有输入参数、返回值 每个包可以有多个 init 函数  包的每个源文件也可以有多个 init 函数   同一个包的 init 执行顺序，golang 没有明确定义，编程时要注意程序不要依赖这个执行顺序 不同包的 init 函数按照包导入的依赖关系决定执行顺序   问答 只想调用该包的 init 函数，不使用包导出的变量或者方法 import _ \u0026#34;net/http/pprof\u0026#34; 执行上述导入后，init 函数会启动一个异步协程采集该进程实例的资源占用情况，并以 http 服务接口方式提供给用户查询。\n 参考 "});index.add({'id':15,'href':'/study-go/docs/design/interface/','title':"interface",'content':"interface Go Data Structures: Interfaces\n读完这篇 go 作者的 blog，interface 就没什么秘密可言了。每个 interface 至少包含两个字段，type 和 data，不论什么形式，然后是 itable 什么时候生成，如何调用。\n结合 Comparison operators，记住 interface 的 compare 规则。\n"});index.add({'id':16,'href':'/study-go/docs/basic/grammar/func/receiver/','title':"Receiver",'content':"Receiver 结构体类型实现的接口，该结构体的指针类型也算实现了\n使用规则  必须使用指针  struct，且包含 sync.Mutex 类型字段   建议使用指针  比较大的 struct/array  struct 或者 array 中的元素个数超过 3 个，则认为比较大，反之，则认为比较小   struct、array 或 slice，其中指针元素所指的内容可能在方法内被修改   建议使用 value 类型  比较小的 struct/array   必须使用 value 类型（编程规范）  map、函数或者 chan 类型 slice，并且方法不会进行 reslice 或者重新分配 slice    method expression package main import ( \u0026#34;fmt\u0026#34; ) type Ball struct { Name string } func (b *Ball) Ping() { fmt.Println(\u0026#34;ping\u0026#34;) } func (b Ball) Pong() { fmt.Println(\u0026#34;pong\u0026#34;) } func main() { v := Ball{} Ball.Ping(\u0026amp;v) Ball.Pong(v) } "});index.add({'id':17,'href':'/study-go/docs/basic/grammar/keyword/','title':"关键字",'content':"Go 语言关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var for 与 range select defer panic 与 recover make 与 new "});index.add({'id':18,'href':'/study-go/docs/appendix/tutorial/','title':"教程",'content':"Go 教程 基础 astaxie/build-web-application-with-golang  A golang ebook intro how to build a web with golang\nmmcgrana/gobyexample  Go by Example\n中文翻译：通过例子学 Golang：https://gobyexample-cn.github.io/\ngeektutu/7days-golang  7 天用 Go 动手写 / 从零实现系列\ngolang101/golang101  Go 语言 101 : 一本侧重于 Go 语言语法和语义的编程解释和指导书 https://gfw.go101.org\n 练习 ardanlabs/gotraining  Go Training Class Material : http://www.ArdanLabs.com\n进阶 Go 语言设计与实现 by Draveness 高阶 "});index.add({'id':19,'href':'/study-go/docs/design/type/','title':"类型系统",'content':"Go 类型系统 Underlying Type  每一个类型都有自己的 Underlying Type  如果 T 是 Pre-declared type 或者 Type Literal，它们对应的 Underlying Type 就是自身 T  比如 type T int 的 Underlying Type 是 int  int 是 Pre-declared   type T map[int]string 的 Underlying Type 是 map[int]string  map[int]string 是 Type Literal     否则 T 的 Underlying Type 是 T 定义时引用的类型的 Underlying Type    Underlying Type 相同 如果两个 type 的 Underlying Type 相同，则它们可以有以下特性：\n  如果两个 type 都是 named type ，彼此之间不能相互赋值\ntype NewString string var my string =\u0026#34;a\u0026#34; // cannot use my (type string) as type NewString in assignment // 虽然它们的 Underlying Type 都是 string，但 string 类型的 my 不能赋值给 NewString 类型的 you var you NewString = my   如果两个 type 其中一个是 Unnamed Type，彼此之间可以相互赋值\npackage main type Ptr *int //named type type Map map[int]string type MapMap Map func main() { var p *int var mm Map var mmm MapMap // m1 m2 是 Unnamed Type  var m1 map[int]string = mm var m2 map[int]string = mmm var ptr Ptr = p print(ptr) print(m1) print(m2) }   原因： 如果为一个类型起了名字，说明你想要做区分，所以两个 named types 即使 Underlying Type 相同也是不能相互赋值的。\n参考：\n 理解 Go 类型系统 Google Group Topic  "});index.add({'id':20,'href':'/study-go/docs/basic/grammar/','title':"语法",'content':"Go 语法 "});index.add({'id':21,'href':'/study-go/docs/basic/grammar/type/','title':"数据类型",'content':"Go 数据类型 基础数据类型 Pre-declarered types 布尔型  数字类型           uint8     uint16     uint32  0 到 4294967295 （42 亿）   uint64     int8 有符号 8 位整型 -128 到 127   int16 有符号 16 位整型 -32768 到 32767   int32  -2147483648 到 2147483647   int64     float32 IEEE-754 32 位浮点型数    float64 IEEE-754 64 位浮点型数    complex64 32 位实数和虚数    complex128 64 位实数和虚数    byte 类似 uint8    rune 类似 int32    uint 32 或 64 位    int 与 uint 一样大小    uintptr 无符号整型，用于存放一个指针     uint 不能直接相减 结果是负数会变成一个很大的 uint，这点对动态语言出身的会可能坑\n 字符串类型  派生类型 Composite Types 指针类型（Pointer） 数组类型 结构化类型 (struct) go struct 能不能比较？\n 因为是强类型语言，所以不同类型的结构不能作比较， 但是同一类型的实例值是可以比较的， 实例不可以比较，因为是指针类型。  Channel 类型 函数类型 切片类型 如果你要创建一个很长的 slice，尽量创建成一个 slice 里存引用，这样可以分批释放，避免 gc 在低配机器上 stop the world\n从 slice 创建 slice 的时候，注意原 slice 的操作可能导致底层数组变化\nJSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？\n接口类型（interface） Map 类型 m := make(map[string]string) "});index.add({'id':22,'href':'/study-go/docs/basic/practice/compile/','title':"编译",'content':"编译 交叉编译 golang 交叉编译很简单的，只要设置几个环境变量就可以了\n# mac上编译linux和windows二进制 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # linux上编译mac和windows二进制 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # windows上编译mac和linux二进制 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go "});index.add({'id':23,'href':'/study-go/docs/basic/grammar/type/interface/','title':"Interface",'content':"Go Interface "});index.add({'id':24,'href':'/study-go/docs/appendix/snippet/','title':"代码片段",'content':"代码片段 slice // 最前面插入一个元素 x = append([]int{1}, x...) // An allocation is only necessary when there is no spare slice capacity. x = append(x, 0) copy(x[1:], x) x[0] = 1 参考： How to prepend int to slice\n"});index.add({'id':25,'href':'/study-go/docs/basic/grammar/func/','title':"函数",'content':"函数 "});index.add({'id':26,'href':'/study-go/docs/basic/grammar/type/channel/','title':"Chiannel",'content':"Chiannel 无缓冲 chan 的发送和接收是否同步 channel 一定记得 close channel 是通过注册相关 goroutine id 实现消息通知的 "});index.add({'id':27,'href':'/study-go/docs/basic/grammar/goroutine/','title':"goroutine",'content':"goroutine golang 并发模型 goroutine 记得 return 或者中断，不然容易造成 goroutine 占用大量 CPU "});index.add({'id':28,'href':'/study-go/docs/basic/pkg/std/sync/mutex/','title':"Mutex",'content':"Mutex Mutex 互斥锁  在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex 使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁  在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁   在 Lock() 之前使用 Unlock() 会导致 panic 异常 已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁 适用于读写不确定，并且只有一个读或者写的场景  type Mutex struct { // contains filtered or unexported fields } func (m *Mutex) Lock() func (m *Mutex) Unlock() RWMutex 读写锁（读多写少） RWMutex 基于 Mutex 实现\n RWMutex 是单写多读锁，该锁可以加一个写锁或者多个读锁 写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占  Lock() 加写锁，Unlock() 解写锁 在 Lock() 之前使用 Unlock() 会导致 panic 异常 如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定   读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁  RLock() 加读锁，RUnlock() 解读锁 RLock() 加读锁时，如果存在写锁，则无法加读锁 在没有读锁的情况下调用 RUnlock() 会导致 panic 错误  RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误     适用于读多写少的场景  "});index.add({'id':29,'href':'/study-go/docs/basic/pkg/std/sync/','title':"sync",'content':"sync "});index.add({'id':30,'href':'/study-go/docs/basic/pkg/','title':"库",'content':"Go 库 "});index.add({'id':31,'href':'/study-go/docs/basic/version/','title':"版本",'content':"Go 版本 golang/go  版本控制 moovweb/gvm  安装：\nzsh \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 版本历史 1.14 (2020/02/25) 1.14 (2020/02/25) 1.13 (2019/09/03) 1.12 (2019/02/25) 1.11 (2018/08/24) 1.10 (2018/02/16) 1.9 (2017/08/24) 1.8 (2017/02/16) 1.7 (2016/08/15) 1.6 (2016/02/17) 1.5 (2015/08/19) Go 1.5 开始，使用 Go 自举实现。\n1.4 (2014/12/10) Go 1.4 之前是 C 实现。\n1.3 (2014/06/18) 1.2 (2013/12/01) 1.1 (2013/05/13) 1 (2012/03/28) "});index.add({'id':32,'href':'/study-go/docs/appendix/attention/','title':"关注",'content':"关注 golang/go  kubernetes/kubernetes  moby/moby  etcd-io/etcd  Distributed reliable key-value store for the most critical data of a distributed system\ncontainous/traefik  The Cloud Native Edge Router https://traefik.io\n Web 框架 gin-gonic/gin  Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance \u0026ndash; up to 40 times faster. If you need smashing performance, get yourself some Gin. https://gin-gonic.com/\nastaxie/beego  beego is an open-source, high-performance web framework for the Go programming language.\n 工具 junegunn/fzf   其他 avelino/awesome-go  fatedier/frp  A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.\ngogs/gogs  Gogs is a painless self-hosted Git service\ncaddyserver/caddy  Fast, multi-platform web server with automatic HTTPS\nfzf is a general-purpose command-line fuzzy finder.\n"});index.add({'id':33,'href':'/study-go/docs/basic/practice/','title':"实践",'content':"Go 实践 "});index.add({'id':34,'href':'/study-go/docs/appendix/interview/','title':"面试题",'content':"Go 语言面试题 基础题 进阶题 高阶题 综合  你遇到过哪些高质量的 Go 语言面试题？  "});index.add({'id':35,'href':'/study-go/docs/','title':"Docs",'content':""});})();
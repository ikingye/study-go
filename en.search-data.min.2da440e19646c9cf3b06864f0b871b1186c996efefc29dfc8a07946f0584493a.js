'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-go/docs/basic/others/quick/','title':"Go 快速上手",'section':"1.4 其他",'content':"Go 快速上手 #  Go 环境 #  GOROOT #  GOROOT: 指定安装 GO 的根目录\nGo 1.0 之后，go tool 利用 GOROOT 查找 Go 编译器（保存在 $GOROOT/pkg/tool/$GOOS_$GOARCH） 和标准库（在 $GOROOT/pkg/$GOOS_$GOARCH）\n可以将 GOROOT 理解为 Java 的 JAVA_HOME。\n我们不应该设置 GOROOT，是因为 Go 工具链已经内置了正确的值。 除非：\n 如果你是 Linux、FreeBSD 或者 OS X 用户，下载了 zip 和 tarball 的二进制包安装环境。这些二进制的默认环境位于 /usr/local/go，建议你将 Go 安装到这个位置。如果选择不这么做，就必须设置到你指定的目录下。 如果你是 Windows 用户，使用 zip 二进制包安装，默认的 GOROOT 在 C:\\Go 目录下。如果你将 Go 安装在其他位置，请设置 GOROOT 到指定的目录。  GOPATH #  GOPATH: go 包的位置\nGOOS vs GOARCH #  随着 go tool 的引入，Go 1.0 之前，GOOS 和 GOARCH 已经变成可选了，因为构建脚本已经能自动检测出系统类别和 CPU 架构。\n在 Go 1.0 的发布后，引入了 cmd/dist 引导构建工具，GOOS 和 GOARCH 真正意义上是可选项了，仅仅在交叉编译时才会用到。\n"});index.add({'id':1,'href':'/study-go/docs/basic/std/sort/','title':"sort",'section':"1.2 标准库",'content':"sort #  自定义排序 #  实现 Len、Less 和 Swap 方法\n// 有时候，我们可能想根据自然顺序以外的方式来对集合进行排序。 // 例如，假设我们要按字符串的长度而不是按字母顺序对它们进行排序。 // 这儿有一个在 Go 中自定义排序的示例。  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) // 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。 // 我们在这里创建了一个 `byLength` 类型，它只是内建类型 `[]string` 的别名。 type byLength []string // 我们为该类型实现了 `sort.Interface` 接口的 `Len`、`Less` 和 `Swap` 方法， // 这样我们就可以使用 `sort` 包的通用 `Sort` 方法了， // `Len` 和 `Swap` 在各个类型中的实现都差不多， // `Less` 将控制实际的自定义排序逻辑。 // 在这个的例子中，我们想按字符串长度递增的顺序来排序， // 所以这里使用了 `len(s[i])` 和 `len(s[j])` 来实现 `Less`。 func (s byLength) Len() int { return len(s) } func (s byLength) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s byLength) Less(i, j int) bool { return len(s[i]) \u0026lt; len(s[j]) } // 一切准备就绪后，我们就可以通过将切片 `fruits` 强转为 `byLength` 类型的切片， // 然后对该切片使用 `sort.Sort` 来实现自定义排序。 func main() { fruits := []string{\u0026#34;peach\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;kiwi\u0026#34;} sort.Sort(byLength(fruits)) fmt.Println(fruits) } "});index.add({'id':2,'href':'/study-go/docs/basic/spec/baidu/','title':"百度",'section':"1.3 编程规范",'content':"百度 Golang 编码规范 V1.2 #  "});index.add({'id':4,'href':'/study-go/docs/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':6,'href':'/study-go/docs/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':8,'href':'/study-go/docs/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':10,'href':'/study-go/docs/code/source/1.0.1/','title':"1.0.0",'section':"3.7 源码分析",'content':"Go 1.0.0 源码分析 #  https://github.com/golang/go/tree/go1.0.1\n 代码行数 #  AlDanial/cloc $ cloc . 15969 text files. 15884 unique files. 13164 files ignored. github.com/AlDanial/cloc v 1.86 T=19.15 s (146.5 files/s, 35024.2 lines/s) -------------------------------------------------------------------------------- Language files blank comment code -------------------------------------------------------------------------------- Go 2023 38800 49499 302225 C 369 20497 20388 149600 HTML 58 4234 252 25508 C/C++ Header 98 1752 2759 15100 Assembly 134 1510 2073 8203 yacc 6 449 396 5212 Perl 12 718 937 4774 Python 6 577 749 2898 JavaScript 6 591 422 2594 XML 16 91 20 1298 Bourne Shell 13 172 348 1064 CSS 6 121 32 888 Bourne Again Shell 17 173 147 758 Lisp 2 108 147 618 vim script 9 94 157 456 Pascal 1 48 222 256 DOS Batch 4 44 1 193 make 19 64 64 161 WiX source 1 12 13 139 awk 2 12 35 104 YAML 3 14 12 60 JSON 2 0 0 20 -------------------------------------------------------------------------------- SUM: 2807 70081 78673 522129 -------------------------------------------------------------------------------- "});index.add({'id':11,'href':'/study-go/docs/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"Go 语法 #  变量 #  var a string = \u0026#34;short\u0026#34; // Go 会自动推断已经有初始值的变量的类型。 var b = true // 声明后却没有给出对应的初始值时，变量将会初始化为零值 。 // 例如，`int` 的零值是 `0`。 var c int // `:=` 语法是声明并初始化变量的简写， d := \u0026#34;short\u0026#34;  常量 #  const 语句可以出现在任何 var 语句可以出现的地方\n一个数字可以根据上下文的需要（比如变量赋值、函数调用）自动确定类型。\n// 这里的 `math.Sin` 函数需要一个 `float64` 的参数，`n` 会自动确定类型。 const n = 500000000 fmt.Println(math.Sin(n))  for 循环 #  for 是 Go 中唯一的循环结构。\n// 最基础的方式，单个循环条件。 i := 1 for i \u0026lt;= 3 { fmt.Println(i) i = i + 1 } // 经典的初始/条件/后续 `for` 循环。 for j := 7; j \u0026lt;= 9; j++ { fmt.Println(j) } // 不带条件的 `for` 循环将一直重复执行， // 直到在循环体内使用了 `break` 或者 `return` 跳出循环。 for { fmt.Println(\u0026#34;loop\u0026#34;) break } // 你也可以使用 `continue` 直接进入下一次循环。 for n := 0; n \u0026lt;= 5; n++ { if n%2 == 0 { continue } fmt.Println(n) }  switch #  case 表达式可以不使用常量\n不带表达式的 switch 是实现 if/else 逻辑的另一种方式。\nt := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;It\u0026#39;s before noon\u0026#34;) default: fmt.Println(\u0026#34;It\u0026#39;s after noon\u0026#34;) } 类型开关 (type switch) 比较类型而非值。可以用来发现一个接口值的类型。\n// 在这个例子中，变量 `t` 在每个分支中会有相应的类型。 whatAmI := func(i interface{}) { switch t := i.(type) { case bool: fmt.Println(\u0026#34;I\u0026#39;m a bool\u0026#34;) case int: fmt.Println(\u0026#34;I\u0026#39;m an int\u0026#34;) default: fmt.Printf(\u0026#34;Don\u0026#39;t know type %T\\n\u0026#34;, t) } } whatAmI(true) whatAmI(1) whatAmI(\u0026#34;hey\u0026#34;)  map #  //创建一个空 map m := make(map[string]int) m[\u0026#34;k1\u0026#34;] = 7 m[\u0026#34;k2\u0026#34;] = 13 // 内建函数 `delete` 可以从一个 map 中移除键值对 delete(m, \u0026#34;k2\u0026#34;) // 可以 选择 使用第二个参数，判断是否存在 key v2, ok := m[\u0026#34;k2\u0026#34;] // 声明并初始化 n := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2} range #  kvs := map[string]string{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2} for k, v := range kvs { } // `range` 也可以只遍历 map 的键 for k := range kvs { } // `range` 在字符串中迭代 unicode 码点(code point)。 // 第一个返回值是字符的起始字节位置，然后第二个是字符本身。 // 输出： // 0 103 // 1 111 // 2 103 // 3 111 for i, c := range \u0026#34;gogo\u0026#34; { fmt.Println(i, c) } // 输出： // 0 // 1 // 2 // 3 for i := range \u0026#34;gogo\u0026#34; { fmt.Println(i) } "});index.add({'id':12,'href':'/study-go/docs/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"Go 数据类型 #  基础数据类型 Pre-declarered types #  布尔型 #   数字类型 #            uint8     uint16     uint32  0 到 4294967295 （42 亿）   uint64     int8 有符号 8 位整型 -128 到 127   int16 有符号 16 位整型 -32768 到 32767   int32  -2147483648 到 2147483647   int64     float32 IEEE-754 32 位浮点型数    float64 IEEE-754 64 位浮点型数    complex64 32 位实数和虚数    complex128 64 位实数和虚数    byte 类似 uint8    rune 类似 int32    uint 32 或 64 位    int 与 uint 一样大小    uintptr 无符号整型，用于存放一个指针     uint 不能直接相减 #  结果是负数会变成一个很大的 uint，这点对动态语言出身的可能有坑\n 字符串类型 #   派生类型 Composite Types #  指针类型（Pointer） #  数组类型 #  结构化类型 (struct) #  go struct 能不能比较？\n 因为是强类型语言，所以不同类型的结构不能作比较， 但是同一类型的实例值是可以比较的， 实例不可以比较，因为是指针类型。  Channel 类型 #  函数类型 #  切片类型 #  如果你要创建一个很长的 slice，尽量创建成一个 slice 里存引用，这样可以分批释放，避免 gc 在低配机器上 stop the world\n从 slice 创建 slice 的时候，注意原 slice 的操作可能导致底层数组变化\nJSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？\n多维 slice #  Slice 可以组成多维数据结构。\n内部的 slice 长度可以不一致，这一点和多维数组不同。\n 接口类型（interface） #  Map 类型 #  m := make(map[string]string)  类型转化 #  Atoi #  // string 到 int int, err := strconv.Atoi(string) // string 到 int64 int64, err := strconv.ParseInt(string, 10, 64) // int 到 string string := strconv.Itoa(int) // int64 到 string string := strconv.FormatInt(int64, 10) "});index.add({'id':13,'href':'/study-go/docs/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"Go 设计模式 #  单例模式 #  常规 #  package singleton import \u0026#34;sync\u0026#34; var ( instance *Instance lock sync.Mutex ) type Instance struct { Name string } // 双重检查 func GetInstance(name string) *Instance { if instance == nil { lock.Lock() defer lock.Unlock() if instance == nil { instance = \u0026amp;Instance{Name: name} } } return instance } sync.Once #  package singleton import \u0026#34;sync\u0026#34; var ( goInstance *Instance once sync.Once ) func GoInstance(name string) *Instance { if goInstance == nil { once.Do(func() { goInstance = \u0026amp;Instance{ Name: name, } }) } return goInstance }  参考 #  tmrts/go-patterns #  senghoo/golang-design-pattern #  "});index.add({'id':14,'href':'/study-go/docs/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"Go 数据类型 #  "});index.add({'id':15,'href':'/study-go/docs/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"Go 教程 #  基础 #  Go by Example #  mmcgrana/gobyexample 中文翻译： gobyexample-cn/gobyexample https://gobyexample-cn.github.io/\nbuild web application with golang #  astaxie/build-web-application-with-golang A golang ebook intro how to build a web with golang\n7days-golang #  geektutu/7days-golang 7 天用 Go 动手写 / 从零实现系列\nGo 语言 101 #  golang101/golang101 Go 语言 101 : 一本侧重于 Go 语言语法和语义的编程解释和指导书 https://gfw.go101.org\nGolang 标准库 #  polaris1119/The-Golang-Standard-Library-by-Example Golang 标准库。对于程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案。\n以示例驱动的方式讲解 Golang 的标准库。\nLearn Go with test #  quii/learn-go-with-tests Learn Go with test-driven development\n1000+ Hand-Crafted Go Examples #  inancgumus/learngo 1000+ Hand-Crafted Go Examples, Exercises, and Quizzes\nThe Little Go Book #  karlseguin/the-little-go-book 《The Little Go Book》中文译本，中文正式名《Go 简易教程》\nsongleo/the-little-go-book_ZH_CN Go Training Class Material #  ardanlabs/gotraining Go Developer Roadmap #  Alikhll/golang-developer-roadmap Roadmap to becoming a Go developer in 2020\nThe Ultimate Go Study Guide #  hoanhan101/ultimate-go This material has been acquired and actively maintained by Ardan Labs →\nardanlabs/gotraining-studyguide 李佶澳的博客 - Go 实用编程 #  绝大部分内容来自 Go 的博客（Go 语言官方 10 年博文阅读指引）\n 进阶 #  Go 语言设计与实现 - Draveness #  Go 语言原本 #  golang-design/under-the-hood "});index.add({'id':16,'href':'/study-go/docs/advanced/pkg/cobra/','title':"cobra",'section':"2.3 常用库",'content':"cobra #  spf13/cobra A Commander for modern Go CLI interactions\nquick start #  typically a Cobra-based application will follow the following organizational structure:\n▾ appName/ ▾ cmd/ add.go your.go commands.go here.go main.go In a Cobra app, typically the main.go file is very bare. It serves one purpose: initializing Cobra.\npackage main import ( \u0026#34;{pathToYourApp}/cmd\u0026#34; ) func main() { cmd.Execute() } Ideally you place this in app/cmd/root.go:\nvar rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, Short: \u0026#34;Hugo is a very fast static site generator\u0026#34;, Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`, Run: func(cmd *cobra.Command, args []string) { // 在这里写应用逻辑  }, } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } "});index.add({'id':17,'href':'/study-go/docs/basic/std/context/','title':"context",'section':"1.2 标准库",'content':"context #  context.Context #   在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 context.Context 的最大作用。 我们可能会创建多个 Goroutine 来处理一次请求，而 context.Context 的作用就是在不同 Goroutine 之间同步  请求特定数据 取消信号 处理请求的截止时间   多个 Goroutine 同时订阅 ctx.Done() 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作  context.Context 是 Go 语言在 1.7 版本中引入标准库的接口 1，该接口定义了四个需要实现的方法，其中包括：\n Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期； Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个 Channel； Err — 返回 context.Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值；  如果 context.Context 被取消，会返回 Canceled 错误； 如果 context.Context 超时，会返回 DeadlineExceeded 错误；   Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；  type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u0026lt;-chan struct{} Err() error Value(key interface{}) interface{} }  Background #   func Background() Context func TODO() Context func WithCancel(parent Context) (ctx Context, cancel CancelFunc) func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) func WithValue(parent Context, key, val interface{}) Context  从源代码来看，context.Background 和 context.TODO 函数其实也只是互为别名，没有太大的差别。 它们只是在使用和语义上稍有不同：\n context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来； context.TODO 应该只在不确定应该使用哪种上下文时使用；  在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 context.Background 作为起始的上下文向下传递。\n context.emptyCtx #  context 包中最常用的方法还是 context.Background、context.TODO， 这两个方法都会返回预先初始化好的私有变量 background 和 todo， 它们会在同一个 Go 程序中被复用：\nfunc Background() Context { return background } func TODO() Context { return todo } 这两个私有变量都是通过 new(emptyCtx) 语句初始化的， 它们是指向私有结构体 context.emptyCtx 的指针， 这是最简单、最常用的上下文类型。\ncontext.emptyCtx 通过返回 nil 实现了 context.Context 接口，它没有任何特殊的功能。\ntype emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() \u0026lt;-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key interface{}) interface{} { return nil } "});index.add({'id':18,'href':'/study-go/docs/basic/grammar/keyword/defer/','title':"defer",'section':"1.1.2 关键字",'content':"defer #  用于确保程序在执行完成后，会调用某个函数，一般是执行清理工作。\nDefer 的用途跟其他语言的 ensure 或 finally 类似。\n当 defer 释放锁遇到尾递归 #  var mut = sync.Mutex{} func tailRec(i int) int { mut.Lock() // 加锁  defer mut.Unlock() // defer 释放锁  if i == 10 { return i } i++ return tailRec(i) // return 尾递归 } 以上代码执行会发生死锁，原因是 return 语句后的命令先执行，赋值给匿名返回值后，再调用 defer， 因此尾递归中 tailRec 的加锁会在 defer 释放锁之前进行，形成死锁。\n根因是 golang 处理 defer 和 return 的顺序为， 计算 return 语句的返回值、赋值给匿名 / 有名返回值 -\u0026gt;defer-\u0026gt;RET 退出函数\n"});index.add({'id':19,'href':'/study-go/docs/basic/grammar/type/error/','title':"error",'section':"1.1.1 数据类型",'content':"error #  实现 Error() string 方法的类型，都是 error 类型\ntype error interface { Error() string } errors.New(\u0026#34;xxxx\u0026#34;) fmt.Errorf(format string, a ...interface{}) "});index.add({'id':20,'href':'/study-go/docs/basic/grammar/keyword/for/','title':"for 和 range",'section':"1.1.2 关键字",'content':"for 和 range #  map 遍历 #  Go 在运行时为哈希表的遍历引入不确定性，程序不要依赖于哈希表的稳定遍历\n"});index.add({'id':21,'href':'/study-go/docs/code/runtime/init/','title':"Go 初始化",'section':"3.3 运行时",'content':"Go 初始化 #  golang 程序初始化先于 main 函数执行，由 runtime 进行初始化，初始化顺序如下：\n 初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime 需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见 golang 变量的初始化）； 初始化包作用域的变量（该作用域的变量的初始化也并非按照 “从上到下、从左到右” 的顺序，runtime 解析变量依赖关系，没有依赖的变量最先初始化，参见 golang 变量的初始化）； 执行包的 init 函数；   变量初始化 -\u0026gt;init ()-\u0026gt;main () 由于 pack 包的初始化依赖 test_util，因此运行时先初始化 test_util 再初始化 pack 包；   同一个包不同源文件的 init 函数执行顺序，golang spec 没做说明  一般是源文件名称的字典序，但不能依赖这个假定     在每一个初始化周期，运行时（runtime）会挑选一个没有任何依赖的变量初始化  该过程一直持续到所有的变量均被初始化或者出现依赖嵌套的情形   同一个 package 下多个文件的变量初始化依赖也遵循相同的规则   变量初始化 #  不同作用域类型的变量初始化顺序不同\n函数作用域内的局部变量 #  初始化顺序：从左到右、从上到下\npackage 级别的变量 #  初始化顺序与初始化依赖有关\n "});index.add({'id':22,'href':'/study-go/docs/code/runtime/scheduling/','title':"Go 调度",'section':"3.3 运行时",'content':"Go 调度 #  Go 调度器的发展 #   单线程调度器・0.x  只包含 40 多行代码； 程序中只能存在一个活跃线程，由 G-M 模型组成；   多线程调度器・1.0  允许运行多线程的程序； 全局锁导致竞争严重；   任务窃取调度器・1.1  引入了处理器 P，构成了目前的 G-M-P 模型； 在处理器 P 的基础上实现了基于工作窃取的调度器； 在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题； 时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；   抢占式调度器・1.2 ~ 至今  基于协作的抢占式调度器 - 1.2 ~ 1.13  通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度； Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；   基于信号的抢占式调度器 - 1.14 ~ 至今  实现基于信号的真抢占式调度； 垃圾回收在扫描栈时会触发抢占调度； 抢占的时间点不够多，还不能覆盖全部的边缘情况；     非均匀存储访问调度器・提案  对运行时的各种资源进行分区； 实现非常复杂，到今天还没有提上日程；    除了多线程、任务窃取和抢占式调度器之外，Go 语言社区目前还有一个非均匀存储访问（Non-uniform memory access，NUMA）调度器的提案，Go 语言在未来也有实现该提案的可能。\n 参考 #   Go 语言调度器与 Goroutine 实现原理  Scheduling In Go #   Scheduling In Go : Part I - OS Scheduler Scheduling In Go : Part II - Go Scheduler Scheduling In Go : Part III - Concurrency  Garbage Collection In Go #   Garbage Collection In Go : Part I - Semantics Garbage Collection In Go : Part II - GC Traces Garbage Collection In Go : Part III - GC Pacing  "});index.add({'id':23,'href':'/study-go/docs/basic/grammar/keyword/func/init/','title':"init",'section':"函数",'content':"init 函数 #   作用 #   初始化不能采用初始化表达式初始化的变量 程序运行前的注册 实现 sync.Once 功能   特点 #   init 函数先于 main 函数自动执行 init 不能被其他函数调用 init 函数没有输入参数、返回值 每个包可以有多个 init 函数  包的每个源文件也可以有多个 init 函数   同一个包的 init 执行顺序，golang 没有明确定义，编程时要注意程序不要依赖这个执行顺序 不同包的 init 函数按照包导入的依赖关系决定执行顺序   问答 #  只想调用该包的 init 函数，不使用包导出的变量或者方法 #  import _ \u0026#34;net/http/pprof\u0026#34; 执行上述导入后，init 函数会启动一个异步协程采集该进程实例的资源占用情况，并以 http 服务接口方式提供给用户查询。\n 参考 #  "});index.add({'id':24,'href':'/study-go/docs/code/keyword/interface/','title':"interface",'section':"3.2 关键字",'content':"interface #  Go Data Structures: Interfaces\n读完这篇 go 作者的 blog，interface 就没什么秘密可言了。每个 interface 至少包含两个字段，type 和 data，不论什么形式，然后是 itable 什么时候生成，如何调用。\n结合 Comparison operators，记住 interface 的 compare 规则。\n"});index.add({'id':25,'href':'/study-go/docs/basic/grammar/keyword/func/receiver/','title':"Receiver",'section':"函数",'content':"Receiver #   value method 可以被 value 和 pointer 对象调用  结构体类型实现的接口，该结构体的指针类型也算实现了该接口   而 pointer method 只能被 pointer 对象调用  pointer method 会修改对象的值，而 value method 不会，所以如果在一个 value 对象上调用 pointer method，编译器会对原来的值做一份拷贝，并在拷贝后的值上执行函数，那么如果函数有修改原 receiver 的值，则修改的行为都发生在拷贝的值上，而不会影响原值，这个错误很隐蔽不容易被调试发现，因此 go 决定放弃这个错误发生的可能性，直接不支持 pointer method 被 value 对象调用。    使用规则 #   必须使用指针  struct，且包含 sync.Mutex 类型字段   建议使用指针  比较大的 struct/array  struct 或者 array 中的元素个数超过 3 个，则认为比较大，反之，则认为比较小   struct、array 或 slice，其中指针元素所指的内容可能在方法内被修改   建议使用 value 类型  比较小的 struct/array   必须使用 value 类型（编程规范）  map、函数或者 chan 类型 slice，并且方法不会进行 reslice 或者重新分配 slice    value vs pointer #  参考：\n Should I define methods on values or pointers?  "});index.add({'id':26,'href':'/study-go/docs/basic/others/pros-and-cons/','title':"优劣",'section':"1.4 其他",'content':"Go 语言优劣 #  Go 的优点 #  部署简单 #   直接编译成机器码 不依赖其他库 直接运行即可部署  静态类型语言 #  编译时可检测出隐藏的大多数问题\n语言层面实现并发（goroutine） #  强大的标准库 #   runtime 系统调度机制 高效的 GC（垃圾回收） 丰富的标准库  简单易学 #   25 个关键字 内嵌 C 语法支持（CGO） 面向对象 跨平台  背靠大厂（Google） #  性能好 #   Go 的缺点 #  无泛化类型 #  传言 Go 2.0 会加上\n无 Exception，都用 Error #  有争议\n包管理大部分在 Github #  参考：\n 2020 年以后是 Go 的天下吗？  "});index.add({'id':27,'href':'/study-go/docs/basic/others/command/install/','title':"安装",'section':"Go 命令",'content':"安装 #  "});index.add({'id':28,'href':'/study-go/docs/basic/std/format/','title':"格式化输出",'section':"1.2 标准库",'content':"格式化输出 #  // Go 提供了一些用于格式化常规值的打印“动词”。 // 例如，这样打印 `point` 结构体的实例。 p := point{1, 2} fmt.Printf(\u0026#34;%v\\n\u0026#34;, p) // 如果值是一个结构体，`%+v` 的格式化输出内容将包括结构体的字段名。 fmt.Printf(\u0026#34;%+v\\n\u0026#34;, p) // `%#v` 根据 Go 语法输出值，即会产生该值的源码片段。 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, p) // 需要打印值的类型，使用 `%T`。 fmt.Printf(\u0026#34;%T\\n\u0026#34;, p) // 格式化布尔值很简单。 fmt.Printf(\u0026#34;%t\\n\u0026#34;, true) // 格式化整型数有多种方式，使用 `%d` 进行标准的十进制格式化。 fmt.Printf(\u0026#34;%d\\n\u0026#34;, 123) // +123 (输出符号) fmt.Printf(\u0026#34;%+d\\n\u0026#34;, 123) // 这个输出二进制表示形式。 fmt.Printf(\u0026#34;%b\\n\u0026#34;, 14) // 输出给定整数的对应字符。 fmt.Printf(\u0026#34;%c\\n\u0026#34;, 33) // `%x` 提供了十六进制编码。 fmt.Printf(\u0026#34;%x\\n\u0026#34;, 456) // 同样的，也为浮点型提供了多种格式化选项。 // 使用 `%f` 进行最基本的十进制格式化。 fmt.Printf(\u0026#34;%f\\n\u0026#34;, 78.9) // `%e` 和 `%E` 将浮点型格式化为（稍微有一点不同的）科学记数法表示形式。 fmt.Printf(\u0026#34;%e\\n\u0026#34;, 123400000.0) fmt.Printf(\u0026#34;%E\\n\u0026#34;, 123400000.0) // 使用 `%s` 进行基本的字符串输出。 fmt.Printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;\\\u0026#34;string\\\u0026#34;\u0026#34;) // 像 Go 源代码中那样带有双引号的输出，使用 `%q`。 fmt.Printf(\u0026#34;%q\\n\u0026#34;, \u0026#34;\\\u0026#34;string\\\u0026#34;\u0026#34;) // 和上面的整型数一样，`%x` 输出使用 base-16 编码的字符串， // 每个字节使用 2 个字符表示。 fmt.Printf(\u0026#34;%x\\n\u0026#34;, \u0026#34;hex this\u0026#34;) // 要输出一个指针的值，使用 `%p`。 fmt.Printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;p) // 格式化数字时，您经常会希望控制输出结果的宽度和精度。 // 要指定整数的宽度，请在动词 \u0026#34;%\u0026#34; 之后使用数字。 // 默认情况下，结果会右对齐并用空格填充。 fmt.Printf(\u0026#34;|%6d|%6d|\\n\u0026#34;, 12, 345) // 你也可以指定浮点型的输出宽度，同时也可以通过 `宽度.精度` 的语法来指定输出的精度。 fmt.Printf(\u0026#34;|%6.2f|%6.2f|\\n\u0026#34;, 1.2, 3.45) // 要左对齐，使用 `-` 标志。 fmt.Printf(\u0026#34;|%-6.2f|%-6.2f|\\n\u0026#34;, 1.2, 3.45) // 你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。 // 这是基本的宽度右对齐方法。 fmt.Printf(\u0026#34;|%6s|%6s|\\n\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;b\u0026#34;) // 要左对齐，和数字一样，使用 `-` 标志。 fmt.Printf(\u0026#34;|%-6s|%-6s|\\n\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;b\u0026#34;) // 到目前为止，我们已经看过 `Printf` 了， // 它通过 `os.Stdout` 输出格式化的字符串。 // `Sprintf` 则格式化并返回一个字符串而没有任何输出。 s := fmt.Sprintf(\u0026#34;a %s\u0026#34;, \u0026#34;string\u0026#34;) fmt.Println(s) // 你可以使用 `Fprintf` 来格式化并输出到 `io.Writers` 而不是 `os.Stdout`。 fmt.Fprintf(os.Stderr, \u0026#34;an %s\\n\u0026#34;, \u0026#34;error\u0026#34;) "});index.add({'id':29,'href':'/study-go/docs/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"Go 语言关键字 #  break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var for 与 range #  select #  defer #  panic 与 recover #  make 与 new #  "});index.add({'id':30,'href':'/study-go/docs/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"Go 标准库 #  教程 #  polaris1119/The-Golang-Standard-Library-by-Example #  Golang 标准库。对于程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案。\n以示例驱动的方式讲解 Golang 的标准库。\n"});index.add({'id':31,'href':'/study-go/docs/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"Go 算法实现 #  "});index.add({'id':32,'href':'/study-go/docs/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"Go 关键字 #  "});index.add({'id':33,'href':'/study-go/docs/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"Go 语言面试题 #  基础题 #   Using reference to loop iterator variable Using goroutines on loop iterator variables  参考：go 易错点\n进阶题 #  综合 #   shomali11/go-interview  lifei6671/interview-go  你遇到过哪些高质量的 Go 语言面试题？  "});index.add({'id':34,'href':'/study-go/docs/advanced/frame/beego/','title':"Beego",'section':"2.7 框架",'content':"Beego #  "});index.add({'id':35,'href':'/study-go/docs/basic/others/gobuild/','title':"Go build",'section':"1.4 其他",'content':"Go build #  -tag #  // +build dev 前后须有一个空行隔开\n release_config.go 文件 go build -tags dev -o dev_version  // +build dev  package main var version = \u0026#34;DEV\u0026#34;  dev_config.go 文件 go build -tags dev -o dev_version  // +build release  package main const version = \u0026#34;RELEASE\u0026#34;  Go 热编译工具 #  caixw/gobuild #  gobuild 是一个简单的 Go 代码热编译工具。 会实时监控指定目录下的文件变化 (重命名，删除，创建，添加)，并编译和运行程序。\ngobuild [options] [dependents] options: -h 显示当前帮助信息； -v 显示 gobuild 和 Go 程序的版本信息； -r 是否搜索子目录，默认为 true； -i 是否显示被标记为 IGNORE 的日志内容，默认为 false，即不显示； -o 执行编译后的可执行文件名； -x 传递给编译程序的参数； -ext 需要监视的扩展名，默认值为\u0026#34;go\u0026#34;，区分大小写，会去掉每个扩展名的首尾空格。 若需要监视所有类型文件，请使用 *，传递空值代表不监视任何文件； -main 指定需要编译的文件，默认为\u0026#34;\u0026#34;。 dependents: 指定其它依赖的目录，只能出现在命令的尾部。 penggy/gobuild #  EasyDarwin 依赖\n# go tools go get -u -v github.com/kardianos/govendor go get -u -v github.com/penggy/gobuild # npm tools npm i -g apidoc npm i -g rimraf "});index.add({'id':36,'href':'/study-go/docs/basic/others/gopls/','title':"gopls",'section':"1.4 其他",'content':"gopls #  gopls (pronounced: \u0026ldquo;go please\u0026rdquo;) is the official language server for the Go language.\nGo 扩展默认是使用大量的 Go 工具来提供各种功能的， 每个工具提供某个方面的能力，比如代码提示是依靠 gocode 的.\n不过微软在开发 VS Code 过程中，定义一种协议，语言服务器协议， Language Server Protocol.\n这可是个好东西，如果你需要开发编辑器或 IDE, 就不需要再为每种语言实现诸如自动完成，代码提示等功能了， 直接利用 语言服务器协议 就行了.\ngopls 就是官方的语言服务器，当前处于 alpha 状态.\n"});index.add({'id':37,'href':'/study-go/docs/basic/grammar/type/slice/','title':"切片",'section':"1.1.1 数据类型",'content':"Go 切片 #  "});index.add({'id':38,'href':'/study-go/docs/basic/others/pm/','title':"包管理",'section':"1.4 其他",'content':"包管理 #  Go 包管理概述 #  Go 1.4 及之前 #   必须设置 GOPATH 环境变量，且源代码必须存放在 GOPATH 下 拉取外部依赖包时，总是拉取最新的版本，无法指定需要的版本  设置 GOPATH 环境变量有两个原因：\n 它规定了 go get 命令下载的依赖包的存储位置（$GOPATH/src） 通过设置 GOPATH，可以方便 Golang 计算出 import 的路径  Go 1.5 至 Go 1.10 #  每个项目的根目录下可以有一个 vendor 目录，里面存放了该项目的依赖的包\nGo 1.11 至 Go 1.12 #   默认使用的还是 GOPATH 的管理方式 运行 export GO111MODULE=on，使用 Go Modules  GO111MODULE 为 off 时：\n 优先使用 vendor 目录下面的包， 如果 vendor 下面没有搜索到，再搜索 $GOPATH/src 下面的包， 如果 $GOPATH 下面没有搜索到，那么搜索 $GOROOT/src 下面的包  Go 1.13 及之后 #  Golang 的包管理默认使用 Go Modules\n Go 包管理工具发展 #  monorepo #  所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包\n vendor #  从 Go 1.5 开始开始引入 vendor 包模式，如果项目目录下有 vendor 目录，那么 go 工具链会优先使用 vendor 内的包进行编译、测试等， 这之后第三方的包管理思路都是通过这种方式来实现，比如说由社区维护准官方包管理工具 dep\nDep #  golang/dep Go 1.9 及之后\n由于 Golang 作者跟 Dep 作者在 Dep 设计上的分歧，Golang 官方在 2018 年 5 月开始推 Go modules，并在 Go 1.13 中默认启用。 曾今自认为 Golang 官方的实验性工具就此没落，很少再有人维护了。 因此，建议 Dep 用户迁移到 Go modules。\nGlide #  Masterminds/glide govendor #  kardianos/govendor  Go Modules #   Go 1.11 - Go 1.12，运行 export GO111MODULE=on，使用 Go Modules Go 1.13 之后，默认使用 Go Modules  $GOPATH 不再作为 build 时导入的角色， 依赖包会存放在 $GOPATH/pkg/mod 目录下。\n Go Modules 原理 #  命令 #  # 下载所有依赖 go mod download # 升级次级或补丁版本号 go get -u rsc.io/quote # 仅升级补丁版本号 go get -u=patch rscio/quote # 整理并更新 go.mod go mod tidy # 仅仅修改 go.mod 配置文件的内容 go mod edit --droprequire=golang.org/x/crypto # 查看 go.mod 内容 go list -m all # json 格式输出 go list -m -json all # 格式化 go.mod go mod edit -fmt  Module-aware mode vs GOPATH mode #  Module-aware mode is active by default whenever a go.mod file is found in the current directory or in any parent directory.\n GO111MODULE  off  the go command never uses module support. Instead it looks in vendor directories and GOPATH to find dependencies   on  the go command requires the use of modules, never consulting GOPATH.   or auto (the default)  Module support is enabled only when the current directory contains a go.mod file or is below a directory containing a go.mod file.      In module-aware mode, GOPATH no longer defines the meaning of imports during a build, but it still stores downloaded dependencies (in GOPATH/pkg/mod) and installed commands (in GOPATH/bin, unless GOBIN is set).\n replace #  go modules 下 import 不再支持使用相对路径导入包，例如 import \u0026quot;./mypkg\u0026quot;，所以需要考虑 replace\n本地替换的价值在于它提供了一种使自动生成的代码进入 go modules 系统的途径， 毕竟不管是 go tools 还是 rpc 工具，这些自动生成代码也是项目的一部分，如果不能纳入包管理器的管理范围想必会带来很大的麻烦。\nreplace 不会生成 go.sum 信息 #  使用本地包进行替换时并不会生成 go.sum 所需的信息，所以 go.sum 文件也没有生成。\nreplace 命令只能管理顶层依赖 #  一个包是顶层依赖还是间接依赖，取决于它在本 module 中是否被直接 import，而不是在 go.mod 文件中是否包含 // indirect 注释。\n不管是直接编辑还是 go mod edit 修改，我们为 go.mod 添加的信息都只是对 go mod 的一种提示而已， 当运行 go build 或是 go mod tidy 时 golang 会自动更新 go.mod 导致某些修改无效，\n go.sum #  go.sum 是一个构建状态跟踪文件。它会记录当前 module 所有的顶层和间接依赖，以及这些依赖的校验和，从而提供一个可以 100% 复现的构建过程并对构建对象提供安全性的保证。\n应该把 go.sum 和 go.mod 一同添加进版本控制工具的跟踪列表，同时需要随着你的模块一起发布。如果你发布的模块中不包含此文件，使用者在构建时会报错，同时还可能出现安全风险（go.sum 提供了安全性的校验）。\ngo.sum 不是锁文件 #  npm 的 package-lock.json 是锁文件，go.sum 不是。\ngo.sum 同时还会保留过去使用的包的版本信息，以便日后可能的版本回退，这一点也与普通的锁文件不同。所以 go.sum 并不是包管理器的锁文件。\n go mod vendor #  这个命令并不能让你从 godep 之类的工具迁移到 go modules，它只是单纯地把 go.sum 中的所有依赖下载到 vendor 目录里\n使用 go build -mod=vendor 来构建项目\n参考：\n Using Go Modules   参考 #  "});index.add({'id':39,'href':'/study-go/docs/basic/grammar/type/array/','title':"数组",'section':"1.1.1 数据类型",'content':"Go 数组 #  什么时候使用数组，而不是切片？ #   arrays are hashable. That means they can be used as a key to a map can be serialized by encoding/binary pass by value. planning the detailed layout of memory  参考：\n Why use arrays instead of slices?  "});index.add({'id':40,'href':'/study-go/docs/code/type/type/','title':"类型系统",'section':"3.1 数据类型",'content':"Go 类型系统 #  Underlying Type #   每一个类型都有自己的 Underlying Type  如果 T 是 Pre-declared type 或者 Type Literal，它们对应的 Underlying Type 就是自身 T  比如 type T int 的 Underlying Type 是 int  int 是 Pre-declared   type T map[int]string 的 Underlying Type 是 map[int]string  map[int]string 是 Type Literal     否则 T 的 Underlying Type 是 T 定义时引用的类型的 Underlying Type    Underlying Type 相同 #  如果两个 type 的 Underlying Type 相同，则它们可以有以下特性：\n  如果两个 type 都是 named type ，彼此之间不能相互赋值\ntype NewString string var my string =\u0026#34;a\u0026#34; // cannot use my (type string) as type NewString in assignment // 虽然它们的 Underlying Type 都是 string，但 string 类型的 my 不能赋值给 NewString 类型的 you var you NewString = my   如果两个 type 其中一个是 Unnamed Type，彼此之间可以相互赋值\npackage main type Ptr *int //named type type Map map[int]string type MapMap Map func main() { var p *int var mm Map var mmm MapMap // m1 m2 是 Unnamed Type  var m1 map[int]string = mm var m2 map[int]string = mmm var ptr Ptr = p print(ptr) print(m1) print(m2) }   原因： 如果为一个类型起了名字，说明你想要做区分，所以两个 named types 即使 Underlying Type 相同也是不能相互赋值的。\n参考：\n 理解 Go 类型系统 Google Group Topic  "});index.add({'id':41,'href':'/study-go/docs/basic/others/compile/','title':"编译",'section':"1.4 其他",'content':"编译 #  Makefile #  Go Makefile 样例 #  include .env PROJECTNAME=$(shell basename \u0026#34;$(PWD)\u0026#34;) # Go related variables. GOBASE=$(shell pwd) GOPATH=\u0026#34;$(GOBASE)/vendor:$(GOBASE)\u0026#34; GOBIN=$(GOBASE)/bin GOFILES=$(wildcard *.go) # Redirect error output to a file, so we can show it in development mode. STDERR=/tmp/.$(PROJECTNAME)-stderr.txt # PID file will keep the process id of the server PID=/tmp/.$(PROJECTNAME).pid # Make is verbose in Linux. Make it silent. MAKEFLAGS += --silent ## install: Install missing dependencies. Runs `go get` internally. e.g; make install get=github.com/foo/bar install: go-get ## start: Start in development mode. Auto-starts when code changes. start: bash -c \u0026#34;trap \u0026#39;make stop\u0026#39; EXIT; $(MAKE)compile start-server watch run=\u0026#39;make compile start-server\u0026#39;\u0026#34; ## stop: Stop development mode. stop: stop-server start-server: stop-server @echo \u0026#34; \u0026gt; $(PROJECTNAME)is available at $(ADDR)\u0026#34; @-$(GOBIN)/$(PROJECTNAME) 2\u0026gt;\u0026amp;1 \u0026amp; echo $$! \u0026gt; $(PID) @cat $(PID) | sed \u0026#34;/^/s/^/ \\\u0026gt; PID: /\u0026#34; stop-server: @-touch $(PID) @-kill `cat $(PID)` 2\u0026gt; /dev/null || true @-rm $(PID) ## watch: Run given command when code changes. e.g; make watch run=\u0026#34;echo \u0026#39;hey\u0026#39;\u0026#34; watch: @GOPATH=$(GOPATH) GOBIN=$(GOBIN) yolo -i . -e vendor -e bin -c \u0026#34;$(run)\u0026#34; restart-server: stop-server start-server ## compile: Compile the binary. compile: @-touch $(STDERR) @-rm $(STDERR) @-$(MAKE) -s go-compile 2\u0026gt; $(STDERR) @cat $(STDERR) | sed -e \u0026#39;1s/.*/\\nError:\\n/\u0026#39; | sed \u0026#39;s/make\\[.*/ /\u0026#39; | sed \u0026#34;/^/s/^/ /\u0026#34; 1\u0026gt;\u0026amp;2 ## exec: Run given command, wrapped with custom GOPATH. e.g; make exec run=\u0026#34;go test ./...\u0026#34; exec: @GOPATH=$(GOPATH) GOBIN=$(GOBIN) $(run) ## clean: Clean build files. Runs `go clean` internally. clean: @(MAKEFILE) go-clean go-compile: go-clean go-get go-build go-build: @echo \u0026#34; \u0026gt; Building binary...\u0026#34; @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go build -o $(GOBIN)/$(PROJECTNAME) $(GOFILES) go-generate: @echo \u0026#34; \u0026gt; Generating dependency files...\u0026#34; @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go generate $(generate) go-get: @echo \u0026#34; \u0026gt; Checking if there is any missing dependencies...\u0026#34; @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go get $(get) go-install: @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go install $(GOFILES) go-clean: @echo \u0026#34; \u0026gt; Cleaning build cache\u0026#34; @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go clean .PHONY: help all: help help: Makefile @echo @echo \u0026#34; Choose a command run in \u0026#34;$(PROJECTNAME)\u0026#34;:\u0026#34; @echo @sed -n \u0026#39;s/^##//p\u0026#39; $\u0026lt; | column -t -s \u0026#39;:\u0026#39; | sed -e \u0026#39;s/^/ /\u0026#39; @echo 参考：\n A Good Makefile for Go   交叉编译 #  golang 交叉编译很简单的，只要设置几个环境变量就可以了\n# mac上编译linux和windows二进制 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # linux上编译mac和windows二进制 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build # windows上编译mac和linux二进制 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go "});index.add({'id':42,'href':'/study-go/docs/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"Go 编程规范 #  代码组织 #  目录 #  /cmd # 程序和库的私有代码。这里的代码都是你不希望被别的应用和库所引用的. # 把你真正的应用代码放在 /internal/app 目录 (比如: /internal/app/myapp) 把你的应用间共享的代码放在 /internal/pkg 目录 (比如: internal/pkg/myprivlib) /internal /pkg 不应该存在的目录 #  /src 参考：\n golang-standards/project-layout    文件内容 #  建议文件按以下顺序进行布局：\n General Documentation: 对整个模块和功能的完整描述注释，写在文件头部。 package: 当前 package 定义 imports: 包含的头文件 Constants: 常量 Typedefs: 类型定义 Globals: 全局变量定义 functions: 函数实现   语言规范 #  申明 slice #  申明 slice 时，建议使用 var 方式申明，不建议使用大括号的方式\n// GOOD: var t []string // BAD: t := []string{} embedding #   embedding 只用于 \u0026ldquo;is a\u0026rdquo; 的语义下，而不用于 \u0026ldquo;has a\u0026rdquo; 的语义下  语义上 embedding 是一种继承关系，而不是成员关系   一个定义内，多于一个的 embedding 尽量少用  一个定义内有多个 embedding，则很难判断某个成员变量或函数是从哪里继承得到的 一个定义内有多个 embedding，危害和在 python 中使用 from xxx import * 是类似的    type Automobile struct { // ... } type Engine struct { // .... } // GOOD: type Car struct { Automobile // Car is a Automobile  engine Engine // Car has a Engine } // BAD: type Car struct { Automobile // Car is a Automobile  Engine // Car has a Engine, but Car is NOT a Engine } 函数参数和返回值 #    必须\n 函数返回值小于等于 3 个，大于 3 个时必须通过 struct 进行包装    建议\n 函数参数不建议超过 3 个，大于 3 个时建议通过 struct 进行包装 函数返回值  逻辑判断型：返回值的意义代表 “真” 或 “假”，返回值类型定义为 bool 操作型：返回值的意义代表 “成功” 或 “失败”，返回值类型定义为 error 获取数据型：返回值的意义代表 “有数据” 或 “无数据 / 获取数据失败”，返回值类型定义为（data, error）      缩进 #   使用 tab 进行缩进。 跨行的缩进使用 gofmt 的缩进方式。 设置 tabstop=4  空格 #   圆括号、方括号、花括号内侧都不加空格 逗号、冒号（slice 中冒号除外）前不加空格，后边加一个空格 所有二元运算符前后各加一个空格（作为函数参数时除外）  var ( s = make([]int, 10) ) // GOOD： func foo() { m := map[string]string{\u0026#34;language\u0026#34;: \u0026#34;golang\u0026#34;} r := 1 + 2 func1(1+2) fmt.Println(m[\u0026#34;language\u0026#34;]) } // BAD： func foo() { m := map[string]string{ \u0026#34;language\u0026#34; : \u0026#34;golang\u0026#34; } r := 1+2 func1(1 + 2) fmt.Println(m[ \u0026#34;language\u0026#34; ]) }  命名 #  文件名 #  文件名都使用小写字母，如果需要，可以使用下划线分割\n文件名的后缀使用小写字母\n函数名 / 变量名 #  采用驼峰方式命名，禁止使用下划线命名\n首字母是否大写，根据是否需要外部访问来决定\n常量 #  尽量不要在程序中直接写数字，特殊字符串，全部用常量替代\n包名 #  关于包的命名，Go 团队建议以简单，扁平为原则。 例如，strutils 是 string utility 函数的名字，http 是 HTTP 请求的名字。\n包的名字应避免使用下划线，中划线或掺杂大写字母。\n 编程实践 #  error string #  error string 尽量使用小写字母，并且结尾不带标点符号\nDon\u0026rsquo;t panic #  除非出现不可恢复的程序错误，不要使用 panic，用多返回值和 error。\n关于 lock 的保护 #   如果临界区内的逻辑较复杂、无法完全避免 panic 的发生，则要求适用 defer 来调用 Unlock，即使在临界区过程中发生了 panic，也会在函数退出时调用 Unlock 释放锁  go 提供了 recover，可以对 panic 进行捕获，但如果 panic 发生在临界区内，则可能导致对锁的使用没有释放 这种情况下，即使 panic 不会导致整个程序的奔溃，也会由于” 锁不释放 “的问题而使临界区无法被后续的调用访问     上述操作如果造成临界区扩大后，需要建立单独的一个函数访问临界区。  func doDemo() { lock.Lock() // step1: 临界区内的操作  lock.Unlock() // step2: 临界区外的操作 } // 如果改造为 defer 的方式，变为如下代码，实际上扩大了临界区的范围（step2 的操作也被放置在临界区了） func doDemo() { lock.Lock() defer lock.Unlock() // step1: 临界区内的操作  // step2: 临界区外的操作 } // 需要使用单独的匿名函数，专门用于访问临界区 func doDemo() { func() { lock.Lock() defer lock.Unlock() // step1: 临界区内的操作操作  }() // step2: 临界区外的操作 } unsafe package #   除非特殊原因，不建议使用 unsafe package  比如进行指针和数值 uintptr 之间转换就是一个特殊原因    "});index.add({'id':43,'href':'/study-go/docs/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"Go 常用库 #  conf #  spf13/viper #  Go configuration with fangs\n log #  sirupsen/logrus #  Structured, pluggable logging for Go.\nuber-go/zap #  Blazing fast, structured, leveled logging in Go.\nrs/zerolog #  Zero Allocation JSON Logger\napex/log #  Structured logging package for Go.\ngrafana/loki #  Like Prometheus, but for logs.\ngolang/glog #  Leveled execution logs for Go\nkubernetes/klog #   net #  imroc/req #  Go 语言人性化 HTTP 请求库\nvalyala/fasthttp #  Fast HTTP package for Go. Tuned for high performance. Zero memory allocations in hot paths. Up to 10x faster than net/http\n cmd #  spf13/cobra #  A Commander for modern Go CLI interactions\nalecthomas/kong #  Kong is a command-line parser for Go\nalecthomas/kingpin #  CONTRIBUTIONS ONLY: A Go (golang) command line and flag parser\n注：作者已经放弃 kingpin，改用 kong\n web #  gorilla/mux #  A powerful HTTP router and URL matcher for building Go web servers\ngithubnemo/CompileDaemon #  Watches your .go files in a directory and invokes go build if a file changed.\nUsage:\n./CompileDaemon -directory=yourproject/\n其他 #  fsnotify/fsnotify #  Cross-platform file system notifications for Go.\ngomodule/redigo #  Go client for Redis\ngo-redis/redis #  Type-safe Redis client for Golang\nhttps://godoc.org/github.com/go-redis/redis\nspf13/afero #  A FileSystem Abstraction System for Go\n"});index.add({'id':44,'href':'/study-go/docs/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"Go 运行时 #  "});index.add({'id':45,'href':'/study-go/docs/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  golang/go #  kubernetes/kubernetes #  moby/moby #  etcd-io/etcd #  Distributed reliable key-value store for the most critical data of a distributed system\n Web 框架 #  gin-gonic/gin #  Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance \u0026ndash; up to 40 times faster. If you need smashing performance, get yourself some Gin. https://gin-gonic.com/\nastaxie/beego #  beego is an open-source, high-performance web framework for the Go programming language.\ngobuffalo/buffalo #  Rapid Web Development w/Go\n 工具 #  junegunn/fzf #  A command-line fuzzy finder\n模糊查询\n 其他 #  avelino/awesome-go #  fatedier/frp #  A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.\ngogs/gogs #  Gogs is a painless self-hosted Git service\ncaddyserver/caddy #  Fast, multi-platform web server with automatic HTTPS\nfzf is a general-purpose command-line fuzzy finder.\naceld/zinx #  基于 Golang 轻量级 TCP 并发服务器框架\ngolang/glog #  Leveled execution logs for Go\nc-bata/go-prompt #  Building powerful interactive prompts in Go, inspired by python-prompt-toolkit.\ngrpc-ecosystem/grpc-gateway #  gRPC to JSON proxy generator following the gRPC HTTP spec\ngrpc-ecosystem/go-grpc-middleware #  Golang gRPC Middlewares: interceptor chaining, auth, logging, retries and more.\n"});index.add({'id':46,'href':'/study-go/docs/basic/others/command/','title':"Go 命令",'section':"1.4 其他",'content':"Go 命令 #  go get 等于 go get -d 加 go install\ngo get #  -d 只下载不安装 -u 强制使用网络去更新包和它的依赖包 -f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用 -v 显示执行的命令 -t 同时也下载需要为运行测试所需要的包 -fix 在获取源码之后先运行 fix，然后再去做其他的事情 -insecure 允许使用不安全的 HTTP 方式进行下载操作 go get 后面不带参数时 #   go get 等同于 go install go get -d 等同于 go list  参考：\n What is the difference between go get and go install?   go install #   第一步是生成结果文件（可执行文件或者 .a 包）， 第二步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。   go list #   go build #  ldflags #  go tool link --help 查看 ldflags 各参数含义\n -w 禁止生成 debug 信息，注意使用该选项后，无法使用 gdb 进行调试 -s 禁用符号表  go build -ldflags \u0026#39;-w -s\u0026#39; gcflags #  go tool compile --help 查看 gcflags 各参数含义\n -N 禁止编译优化 -l 禁止内联，禁止内联也可以一定程度上减小可执行程序大小  go build -gcflags \u0026#39;-N -l\u0026#39; "});index.add({'id':47,'href':'/study-go/docs/basic/grammar/type/interface/','title':"Interface",'section':"1.1.1 数据类型",'content':"Go Interface #  "});index.add({'id':48,'href':'/study-go/docs/basic/grammar/keyword/func/','title':"函数",'section':"1.1.2 关键字",'content':"函数 #  函数参数 #  值传递 #  golang 中函数的参数传递采用的是值传递。\n在处理 map，channel 和 slice 等这些内置结构的数据时，其实处理的是一个指针类型的数据。\n可变参数 #  package main import \u0026#34;fmt\u0026#34; // 这个函数接受任意数量的 `int` 作为参数。 func sum(nums ...int) { fmt.Print(nums, \u0026#34; \u0026#34;) total := 0 for _, num := range nums { total += num } fmt.Println(total) } func main() { // 变参函数使用常规的调用方式，传入独立的参数。 \tsum(1, 2) sum(1, 2, 3) // 如果你有一个含有多个值的 slice，想把它们作为参数使用， \t// 你需要这样调用 `func(slice...)`。 \tnums := []int{1, 2, 3, 4} sum(nums...) }  方法 #  调用方法时产生一个拷贝 #  r := rect{width: 10, height: 5} // 调用方法时，Go 会自动处理值和指针之间的转换。 // 想要避免在调用方法时产生一个拷贝，或者想让方法可以修改接受结构体的值， // 你都可以使用指针来调用方法。 rp := \u0026amp;r fmt.Println(\u0026#34;area: \u0026#34;, rp.area()) fmt.Println(\u0026#34;perim:\u0026#34;, rp.perim()) "});index.add({'id':49,'href':'/study-go/docs/basic/others/history/','title':"历史",'section':"1.4 其他",'content':"Go 历史 #  "});index.add({'id':50,'href':'/study-go/docs/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':51,'href':'/study-go/docs/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  slice #  contains #  func contains(s []int, e int) bool { for _, a := range s { if a == e { return true } } return false } 使用 map[string] struct{} #  参考：\n Contains method for a slice  最前面插入一个元素 #  // 最前面插入一个元素 x = append([]int{1}, x...) // An allocation is only necessary when there is no spare slice capacity. x = append(x, 0) copy(x[1:], x) x[0] = 1 参考：\n How to prepend int to slice  找出元素位置 #  func SliceIndex(limit int, predicate func(i int) bool) int { for i := 0; i \u0026lt; limit; i++ { if predicate(i) { return i } } return -1 } 参考：\n How to find out element position in slice?   删除元素 #  使用 index 删除\n// 保持有序 func remove(slice []int, s int) []int { return append(slice[:s], slice[s+1:]...) } // 无序 func remove(s []int, i int) []int { s[i] = s[len(s)-1] // We do not need to put s[i] at the end, as it will be discarded anyway  return s[:len(s)-1] } 使用元素值删除\nfunc remove(s []string, e string) []string { result := s[:0] for _, item := range s { if item != e { result = append(result, item) } } return result } 参考：\n How to delete an element from a Slice in Golang 【Golang】slice 删除元素的性能对比  "});index.add({'id':52,'href':'/study-go/docs/basic/grammar/type/channel/','title':"Chiannel",'section':"1.1.1 数据类型",'content':"Chiannel #  channel 类型 #  chan T // can be used to send and receive values of type T chan\u0026lt;- float64 // can only be used to send float64s \u0026lt;-chan int // can only be used to receive ints The \u0026lt;- operator associates with the leftmost chan possible:\nchan\u0026lt;- chan int // same as chan\u0026lt;- (chan int) chan\u0026lt;- \u0026lt;-chan int // same as chan\u0026lt;- (\u0026lt;-chan int) \u0026lt;-chan \u0026lt;-chan int // same as \u0026lt;-chan (\u0026lt;-chan int) chan (\u0026lt;-chan int)  常见用法 #  // 使用 `make(chan val-type)` 创建一个新的通道。 // 通道类型就是他们需要传递值的类型。 messages := make(chan string) // 使用 `channel \u0026lt;-` 语法 _发送_ 一个新的值到通道中。 // 这里我们在一个新的协程中发送 `\u0026#34;ping\u0026#34;` 到上面创建的 `messages` 通道中。 go func() { messages \u0026lt;- \u0026#34;ping\u0026#34; }() // 使用 `\u0026lt;-channel` 语法从通道中 _接收_ 一个值。 // 这里我们会收到在上面发送的 `\u0026#34;ping\u0026#34;` 消息并将其打印出来。 msg := \u0026lt;-messages fmt.Println(msg) // 如果 ok 的值是 false，表明 接收到的是 特别制造的 0 值 —— 因为发送通道关闭了并且为空（closed and empty）。 msg, ok := \u0026lt;-messages done channel #  用于保证流水线上每个阶段 goroutine 的退出\ngolang.org/x/net/context/ctxhttp 中 Do 方法的实现：\n// https://github.com/golang/net/blob/release-branch.go1.7/context/ctxhttp/ctxhttp.go  // Do sends an HTTP request with the provided http.Client and returns // an HTTP response. // // If the client is nil, http.DefaultClient is used. // // The provided ctx must be non-nil. If it is canceled or times out, // ctx.Err() will be returned. func Do(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) { if client == nil { client = http.DefaultClient } resp, err := client.Do(req.WithContext(ctx)) // If we got an error, and the context has been canceled,  // the context\u0026#39;s error is probably more useful.  if err != nil { select { case \u0026lt;-ctx.Done(): err = ctx.Err() default: } } return resp, err }  注意点 #   无缓冲 chan 的发送和接收是否同步 channel 一定记得 close channel 是通过注册相关 goroutine id 实现消息通知的  关闭 channel #   不要从接收端关闭 channel 不要关闭有多个并发发送者的 channel  如果 sender 是唯一的 sender 或是 channel 最后一个活跃的 sender， 那么你应该在 sender 的 goroutine 关闭 channel， 从而通知 receiver (s)(接收者们) 已经没有值可以读了。\n// _关闭_ 一个通道意味着不能再向这个通道发送值了。 // 该特性可以向通道的接收方传达工作已经完成的信息。  package main import \u0026#34;fmt\u0026#34; // 在这个例子中，我们将使用一个 `jobs` 通道，将工作内容， // 从 `main()` 协程传递到一个工作协程中。 // 当我们没有更多的任务传递给工作协程时，我们将 `close` 这个 `jobs` 通道。 func main() { jobs := make(chan int, 5) done := make(chan bool) // 这是工作协程。使用 `j, more := \u0026lt;- jobs` 循环的从 `jobs` 接收数据。 \t// 根据接收的第二个值，如果 `jobs` 已经关闭了， \t// 并且通道中所有的值都已经接收完毕，那么 `more` 的值将是 `false`。 \t// 当我们完成所有的任务时，会使用这个特性通过 `done` 通道通知 main 协程。 \tgo func() { for { j, more := \u0026lt;-jobs if more { fmt.Println(\u0026#34;received job\u0026#34;, j) } else { fmt.Println(\u0026#34;received all jobs\u0026#34;) done \u0026lt;- true return } } }() // 使用 `jobs` 发送 3 个任务到工作协程中，然后关闭 `jobs`。 \tfor j := 1; j \u0026lt;= 3; j++ { jobs \u0026lt;- j fmt.Println(\u0026#34;sent job\u0026#34;, j) } close(jobs) fmt.Println(\u0026#34;sent all jobs\u0026#34;) // 使用前面学到的[通道同步](channel-synchronization)方法等待任务结束。 \t\u0026lt;-done } 参考：\n 如何优雅地关闭 Go channel  Golang chan 避免死锁 #  Golang 的管道 (chan) 无论是否有缓冲，生产者和消费者不可能做到完全解耦， 一旦管道满了，就相当于生产者直接调用消费者。\n如果生产者和消费者使用同一个锁，就是死锁了.\n所以，一个重要的原则就是，在写管道之前，把所有可能的锁 unlock 掉.\nRelated posts:\n 异步编程语言的常见坑 CVPixelBufferRef 与 CVOpenGLTextureRef: 图像处理中内存与显存的交互 集成于 iphp 框架的 PHP 并发模型和工具 蛇形遍历数组 流式布局的原理和代码实现  参考 #   Golang chan 避免死锁  "});index.add({'id':53,'href':'/study-go/docs/basic/grammar/keyword/make/','title':"make",'section':"1.1.2 关键字",'content':"make #  运算符:= 是 make() 的语法糖\n"});index.add({'id':54,'href':'/study-go/docs/basic/grammar/type/map/','title':"Map",'section':"1.1.1 数据类型",'content':"Map #  Golang 中的 map，实际上就是一个 hashtable\n在 golang 中，当 map 作为形参时，虽然是值传递，但是由于 make () 返回的是一个指针类型\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. func makemap(t *maptype, hint int, h *hmap) *hmap { if hint \u0026lt; 0 || hint \u0026gt; int(maxSliceCap(t.bucket.size)) { hint = 0 } ... } 删除 map 元素 #  delete(map, key) 清空 map #  Go 语言中并没有为 map 提供任何清空所有元素的函数、方法， 清空 map 的唯一办法就是重新 make 一个新的 map， 不用担心垃圾回收的效率，Go 语言中的并行垃圾回收效率比写一个清空函数要高效的多。\n 获取 keys #  package main func main() { mymap := make(map[int]string) keys := make([]int, 0, len(mymap)) for k := range mymap { keys = append(keys, k) } } "});index.add({'id':55,'href':'/study-go/docs/basic/grammar/keyword/select/','title':"select",'section':"1.1.2 关键字",'content':"select #  Go 的 选择器（select） 让你可以同时等待多个通道操作。\n将协程、通道和选择器结合，是 Go 的一个强大特性。\n// 在这个例子中，我们将从两个通道中选择。 c1 := make(chan string) c2 := make(chan string) // 各个通道将在一定时间后接收一个值， // 通过这种方式来模拟并行的协程执行（例如，RPC 操作）时造成的阻塞（耗时）。 go func() { time.Sleep(1 * time.Second) c1 \u0026lt;- \u0026#34;one\u0026#34; }() go func() { time.Sleep(2 * time.Second) c2 \u0026lt;- \u0026#34;two\u0026#34; }() // 我们使用 `select` 关键字来同时等待这两个值， // 并打印各自接收到的值。 for i := 0; i \u0026lt; 2; i++ { select { case msg1 := \u0026lt;-c1: fmt.Println(\u0026#34;received\u0026#34;, msg1) case msg2 := \u0026lt;-c2: fmt.Println(\u0026#34;received\u0026#34;, msg2) } } 随机选则 #  除 default 外，如果有多个 case 语句评估通过，那么通过伪随机的方式随机选一个\n非阻塞 #  default 为空 #  func sendTime(c interface{}, seq uintptr) { // Non-blocking send of time on c. \t// Used in NewTimer, it cannot block anyway (buffer). \t// Used in NewTicker, dropping sends on the floor is \t// the desired behavior when the reader gets behind, \t// because the sends are periodic. \tselect { case c.(chan Time) \u0026lt;- Now(): default: } } "});index.add({'id':56,'href':'/study-go/docs/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"Go 测试 #  开源实现 #  onsi/ginkgo #  BDD Testing Framework for Go\n"});index.add({'id':57,'href':'/study-go/docs/basic/std/sync/cond/','title':"Cond",'section':"sync",'content':"Cond #  type Cond struct { // L is held while observing or changing the condition \tL Locker // contains filtered or unexported fields } // Broadcast 会唤醒所有等待 c 的 goroutine func (c *Cond) Broadcast() // Signal 只唤醒 1 个等待 c 的 goroutine func (c *Cond) Signal() // Wait() 会自动释放 c.L，并挂起调用者的 goroutine。之后恢复执行，Wait() 会在返回时对 c.L 加锁。 // 除非被 Signal 或者 Broadcast 唤醒，否则 Wait() 不会返回 func (c *Cond) Wait()  条件  一个条件一定要有一个信号   信号  wait 等待的是信号 signal 发送的是信号 一个信号可以对应到多个条件    sync.Cond vs sync.Mutex #   Mutex  one goroutine for each write and read   Cond  multiple readers wait for the shared resources to be available     参考 #   How to correctly use sync.Cond?  "});index.add({'id':58,'href':'/study-go/docs/code/runtime/gc/','title':"GC",'section':"3.3 运行时",'content':"Go GC #  Garbage Collection\n"});index.add({'id':59,'href':'/study-go/docs/basic/others/plugin/','title':"Go 插件系统",'section':"1.4 其他",'content':"Go 插件系统 #  Go 1.8 版本开始提供了一个创建共享库的新工具，称为 Plugins.\nGo 插件是使用 -buildmode=plugin 标记编译的一个包，用于生成一个共享对象（.so）库文件。 Go 包中的导出的函数和变量被公开为 ELF 符号，可以使用 plugin 包在运行时查找并绑定 ELF 符号。\nGo 编译器能够使用 build flag -buildmode=c-shared 创建 C 风格的动态共享库。\n 编写 plugin #   包名称必须是 main 没有 main 函数 必须有可以导出 (访问) 的变量或者方法   使用 plugin #   加载编译好的插件 plugin.Open(\u0026quot;./plugin_doctor.so\u0026quot;) (*.so 文件路径相对与可执行文件的路径，可以是绝对路径) 寻找插件可到变量 plug.Lookup(\u0026quot;Doctor\u0026quot;), TypeAssert: Symbol (interface {}) 转换成 API 的接口类型 执行 API interface 的方法   优点 #  缺陷 #  插件实现和主应用程序都必须使用完全相同的 Go 工具链版本构建。 由于插件提供的代码将与主代码在相同的进程空间中运行，因此编译的二进制文件应与主应用程序 100% 兼容。\n插件系统迫使你的插件实现与主应用程序产生高度耦合。 即使你可以控制插件和主应用程序，最终结果也非常脆弱且难以维护。 如果插件的作者对主应用程序没有任何控制权，开销会更高。\n参考 #   Go 插件 plugin 教程 Go 插件系统  vladimirvivien/go-plugin-example     "});index.add({'id':60,'href':'/study-go/docs/basic/others/goroutine/','title':"goroutine",'section':"1.4 其他",'content':"goroutine #  golang 并发模型 #  goroutine 记得 return 或者中断，不然容易造成 goroutine 占用大量 CPU #   Goroutine 如何调度？ #  每个线程会都占用 1MB 以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源， 每一次线程上下文的切换都需要消耗约为 1us， 但是 Go 调度器对 Goroutine 的上下文切换约为 0.2us，减少了 80% 的额外开销。\nGo 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销， 同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。\n 一个 Goroutine 既要包含要执行的代码， 又要包含用于执行该代码的栈和 PC、SP 指针。\n参考：\n Go 语言调度器与 Goroutine 实现原理 [译] Go 调度器: M, P 和 G 也谈 goroutine 调度器 Golang 调度器源码分析  "});index.add({'id':61,'href':'/study-go/docs/basic/others/version/gvm/','title':"gvm",'section':"版本",'content':"gvm #  moovweb/gvm 安装：\nzsh \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 使用：\n$ gvm listall $ gvm list $ gvm install go1.15 $ gvm user go1.15 $ gvm uninstall go1.15 # 使用二进制安装 $ gvm install go1.15 -B $ gvm install -h Invalid version: -h Usage: gvm install [version] [options] -s, --source=SOURCE Install Go from specified source. -n, --name=NAME Override the default name for this version. -pb, --with-protobuf Install Go protocol buffers. -b, --with-build-tools Install package build tools. -B, --binary Only install from binary. --prefer-binary Attempt a binary install, falling back to source. -h, --help Display this message. $ gvm help Usage: gvm [command] Description: GVM is the Go Version Manager Commands: version - print the gvm version number get - gets the latest code (for debugging) use - select a go version to use (--default to set permanently) diff - view changes to Go root help - display this usage text implode - completely remove gvm install - install go versions uninstall - uninstall go versions cross - install go cross compilers linkthis - link this directory into GOPATH list - list installed go versions listall - list available versions alias - manage go version aliases pkgset - manage go packages sets pkgenv - edit the environment for a package set  GOPATH 被篡改 #   everytime i login my zsh. my GOPATH is /\u0026hellip;/.gvm/pkgsets/go1.9/global.\n gvm use system gvm pkgenv \u0026lt;edit as required\u0026gt; gvm use system --default 参考：\n How can i use my own GOPATH default?  "});index.add({'id':62,'href':'/study-go/docs/basic/std/sync/mutex/','title':"Mutex",'section':"sync",'content':"Mutex #  Mutex 互斥锁 #   在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex 使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁  在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁   在 Lock() 之前使用 Unlock() 会导致 panic 异常 已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁 适用于读写不确定，并且只有一个读或者写的场景  type Mutex struct { // contains filtered or unexported fields } func (m *Mutex) Lock() func (m *Mutex) Unlock() RWMutex 读写锁（读多写少） #  RWMutex 基于 Mutex 实现\n RWMutex 是单写多读锁，该锁可以加一个写锁或者多个读锁 写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占  Lock() 加写锁，Unlock() 解写锁 在 Lock() 之前使用 Unlock() 会导致 panic 异常 如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定   读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁  RLock() 加读锁，RUnlock() 解读锁 RLock() 加读锁时，如果存在写锁，则无法加读锁 在没有读锁的情况下调用 RUnlock() 会导致 panic 错误  RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误     适用于读多写少的场景  "});index.add({'id':63,'href':'/study-go/docs/basic/std/signal/','title':"signal",'section':"1.2 标准库",'content':"signal #  The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.\nBy default, a synchronous signal is converted into a run-time panic.\nA SIGHUP, SIGINT, or SIGTERM signal causes the program to exit.\nA SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit with a stack dump.\nA SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default behavior (these signals are used by the shell for job control).\nThe SIGPROF signal is handled directly by the Go runtime to implement runtime.CPUProfile.\nOther signals will be caught but no action will be taken.\nSynchronous signals #   SIGBUS 7 SIGFPE 8 SIGSEGV 11  These are only considered synchronous when caused by program execution, not when sent using os.Process.Kill or the kill program or some similar mechanism.\nGo programs will convert a synchronous signal into a run-time panic.\nAsynchronous signals #   SIGTERM 15  kill 默认不带参数，发送的信号就是 SIGTERM 可以被阻塞、处理和忽略   SIGINT 2  the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C).   SIGHUP 1  a program loses its controlling terminal   SIGQUIT 3  the user at the controlling terminal presses the quit character, which by default is ^\\ (Control-Backslash)   SIGILL 4  执行了非法指令    The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.\n func #  Notify #  // Set up channel on which to send signal notifications. // We must use a buffered channel or risk missing the signal // if we\u0026#39;re not ready to receive when the signal is sent. c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) // Block until a signal is received. s := \u0026lt;-c fmt.Println(\u0026#34;Got signal:\u0026#34;, s) "});index.add({'id':64,'href':'/study-go/docs/basic/std/sync/','title':"sync",'section':"1.2 标准库",'content':"sync #   sync.Mutex sync.RWMutex sync.WaitGroup sync.Once sync.Cond  锁的类型 #  Mutex 互斥锁 #  type Mutex struct { state int32 sema uint32 // semaphore 信号量 }  sync.Mutex.Lock 和 sync.Mutex.Unlock  state #  # 8 位 **** **** ***** * * * waitersCount mutexStarving mutexWoken mutexLocked  mutexLocked — 表示互斥锁的锁定状态 mutexWoken — 表示从正常模式被从唤醒 mutexStarving — 当前的互斥锁进入饥饿状态  Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止被饿死，造成高尾延时   waitersCount — 当前互斥锁上等待的 Goroutine 个数 (最多 128 个)   RWMutex #  type RWMutex struct { w Mutex writerSem uint32 readerSem uint32 readerCount int32 readerWait int32 }  写操作使用 sync.RWMutex.Lock 和 sync.RWMutex.Unlock 方法； 读操作使用 sync.RWMutex.RLock 和 sync.RWMutex.RUnlock 方法；    调用 sync.RWMutex.Lock 尝试获取写锁时；  每次 sync.RWMutex.RUnlock 都会将 readerWait 其减一，当它归零时该 Goroutine 就会获得写锁； 将 readerCount 减少 rwmutexMaxReaders 个数以阻塞后续的读操作；   调用 sync.RWMutex.Unlock 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；  读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。\n WaitGroup #  type WaitGroup struct { noCopy noCopy // wg 无法复制 \tstate1 [3]uint32 }  requests := []*Request{...} wg := \u0026amp;sync.WaitGroup{} wg.Add(len(requests)) for _, request := range requests { go func(r *Request) { defer wg.Done() // res, err := service.call(r)  }(request) } wg.Wait() Done #  sync.WaitGroup.Done 只是对 sync.WaitGroup.Add 方法的简单封装， 我们可以向 sync.WaitGroup.Add 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；\n Once #   sync.Once.Do 方法中传入的函数只会被执行一次，哪怕函数中发生了 panic； 两次调用 sync.Once.Do 方法传入不同的函数也只会执行第一次调用的函数；  type Once struct { done uint32 m Mutex }  Cond #  type Cond struct { L Locker // 用于保护内部的 notify 字段 \tnotify notifyList noCopy noCopy // 保证结构体不会在编译期间拷贝 \tchecker copyChecker // 禁止运行期间发生的拷贝 } type notifyList struct { wait uint32 notify uint32 lock mutex head *sudog tail *sudog }   sync.Cond.Wait 将当前 Goroutine 陷入休眠状态  在调用之前一定要使用获取互斥锁，否则会触发程序崩溃   sync.Cond.Signal 唤醒队列最前面的 Goroutine sync.Cond.Broadcast 唤醒队列中全部的 Goroutine  "});index.add({'id':65,'href':'/study-go/docs/basic/std/time/','title':"time",'section':"1.2 标准库",'content':"time #  格式化 #  // 1 2 3 4 5 6 const ANSIC = \u0026#34;Mon Jan _2 15:04:05 2006\u0026#34; time.Now().Format(\u0026#34;2006-01-02 15:04:05\u0026#34;) "});index.add({'id':66,'href':'/study-go/docs/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"Go 版本 #  golang/go #  版本控制 #   gvm   版本历史 #  1.15 (2020-08-11) #  1.15.1 (2020-09-01) #   1.14 (2020-02-25) #   嵌入接口的方法集可重叠  1.14.4 (2020-06-01) #  1.14.6 (2020-07-16) #  参考：\n Go 1.14 中值得关注的几个变化   1.13 (2019-09-03) #   1.12 (2019-02-25) #   1.11 (2018-08-24) #   pprof   1.10 (2018-02-16) #  不用手动设置 GOROOT 了。\n参考：\n 你再也不用设置 GOROOT 了   1.9 (2017-08-24) #   Mutex 互斥锁的饥饿模式  1.8 (2017-02-16) #   http/2 PUSH 功能  1.7 (2016-08-15) #   标准库  context.Context    1.6 (2016-02-17) #   Go HTTP2  http2 is enabled by default in Go 1.6+ with no changes to your code.    1.5 (2015-08-19) #  Go 1.5 开始，使用 Go 自举实现。\n1.4 (2014-12-10) #  Go 1.4 之前是 C 实现。\n1.3 (2014-06-18) #  1.2 (2013-12-01) #  1.1 (2013-05-13) #  从 Go 1.0 开始，GOPATH 就被强烈推荐。随着 Go 1.1 的发布，GOPATH 已经是强制性的了。\n1 (2012-03-28) #  "});index.add({'id':67,'href':'/study-go/docs/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':68,'href':'/study-go/docs/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"Go 框架 #  "});index.add({'id':69,'href':'/study-go/docs/code/source/','title':"3.7 源码分析",'section':"第三部分 设计与实现",'content':"源码分析 #  "});})();